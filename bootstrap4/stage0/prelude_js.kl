-- Built-in structs, enum, and traits

enum Option<T>:
    None
    Some(T)
end

trait ToStr:
    fn to_str(self) str
end

trait Add:
    fn add(self, rhs Self) Self
end

trait Sub:
    fn sub(self, rhs Self) Self
end

trait Mul:
    fn mul(self, rhs Self) Self
end

trait Div:
    fn div(self, rhs Self) Self
end

trait PartialEq:
    fn eq(self, rhs Self) bool
    fn ne(self, rhs Self) bool
end

-- This is just a marker trait. `PartialEq` must be implemented.
trait Eq:
end

trait PartialOrd:
    fn lt(self, rhs Self) bool
    fn le(self, rhs Self) bool
    fn gt(self, rhs Self) bool
    fn ge(self, rhs Self) bool
end

-- This is just a marker trait. `PartialOrd` must be implemented.
trait Ord:
end

trait IndexedGet<T>:
    fn get(self, i i32) T
end

trait IndexedSet<T>:
    fn set(mut self, i i32, v T)
end

trait Iterator<T>:
    fn next(self) T

    fn for_each(self, f fn(T)):
        loop:
            let next = self.next()
            match next:
                Option.None :
                    break
                end
                Option.Some(value) => f(value)
            end
        end
    end

    fn filter(self, f fn(T) bool) Self:
        let vec = Vector<T>.new()
        self.for_each(fn(value) => if f(value) => vec.push(value))
        return vec.iter()
    end

    fn collect(self) Vector<T>:
        let vec = Vector<T>.new()
        self.for_each(fn(value) => vec.push(value))
        return vec
    end
end

trait Len:
    fn len(self) i32
end

extern:

    fn print(s ToStr)
    fn panic(s str)
    -- For compiler debugging purposes only.
    fn jsprint(s str)

    -- i32

    struct i32: 
    end

    impl ToStr for i32:
        fn to_str(self) str
    end

    impl Add for i32:
        fn add(self, rhs Self) Self
    end

    impl Sub for i32:
        fn sub(self, rhs Self) Self
    end

    impl Mul for i32:
        fn mul(self, rhs Self) Self
    end
    
    impl Div for i32:
        fn div(self, rhs Self) Self
    end

    impl PartialEq for i32:
        fn eq(self, rhs Self) bool
        fn ne(self, rhs Self) bool
    end

    impl Eq for i32:
        fn eq(self, rhs Self) bool
        fn ne(self, rhs Self) bool
    end

    impl PartialOrd for i32:
        fn lt(self, rhs Self) bool
        fn le(self, rhs Self) bool
        fn gt(self, rhs Self) bool
        fn ge(self, rhs Self) bool
    end

    impl Ord for i32:
    end

    -- bool

    struct bool:
    end

    impl ToStr for bool:
        fn to_str(self) str
    end

    impl PartialEq for bool:
        fn eq(self, rhs Self) bool
        fn ne(self, rhs Self) bool
    end

    impl PartialOrd for bool:
        fn lt(self, rhs Self) bool
        fn le(self, rhs Self) bool
        fn gt(self, rhs Self) bool
        fn ge(self, rhs Self) bool
    end

    impl Ord for bool:
    end

    -- str

    struct str:
    end

    impl str:
        fn len(self) usize
        fn push(mut self, s str) str
    end

    impl ToStr for str:
        fn to_str(self) str
    end

    impl PartialEq for str:
        fn eq(self, rhs Self) bool
        fn ne(self, rhs Self) bool
    end

    impl Eq for str:
    end

    impl PartialOrd for str:
        fn lt(self, rhs Self) bool
        fn le(self, rhs Self) bool
        fn gt(self, rhs Self) bool
        fn ge(self, rhs Self) bool
    end

    impl Ord for str:
    end

    -- JS array helpers.
    struct JSArray<T>:
    end

    impl JSArray<T>:
        fn new() Self
        fn len(self) i32
        fn push(mut self, s T) 
        fn get(self, i i32) T
        fn set(mut self, i i32, v T)
    end
end

-- Fixed size array
-- This is an internal data structure used by the compiler. 
-- TODO: Don't expose this to the user.

struct array<T>:
    data JSArray<T>
end

impl array<T>:
    fn new(size i32) array<T>:
        return array { data: JSArray<T>.new(size) }
    end

    fn iter(self) ArrayIter<T>:
        return ArrayIter<T> { arr: self, index: 0 }
    end
end

impl Len for array<T>:
    fn len(self) i32:
        return self.data.len()
    end
end

impl IndexedGet<T> for array<T>:
    fn get(self, i i32) T:
        if i >= self.len():
            panic("Array index out of bounds")
        end
        return self.data.get(i)
    end
end

impl IndexedSet<T> for array<T>:
    fn set(mut self, i i32, v T):
        if i >= self.len():
            panic("Array index out of bounds")
        end
        self.data.set(i, v)
    end
end

struct ArrayIter<T>:
    arr array<T>
    index i32
end

impl Iterator<T> for ArrayIter<T>:
    fn next(mut self) Option<T>:
        if self.index >= self.arr.len():
            return Option.None
        end
        let value = self.arr.get(self.index)
        self.index = self.index + 1
        return Option.Some(value)
    end
end

-- Vector

struct Vector<T>:
    data JSArray<T>
end

impl Vector<T>:
    fn new() Vector<T>:
        return Vector { data: JSArray<T>.new(0) }
    end

    fn push(mut self, s T):
        self.data.push(s)
    end

    fn iter(self) VectorIter<T>:
        return VectorIter<T> { vec: self, index: 0 }
    end
end

impl Len for Vector<T>:
    fn len(self) i32:
        return self.data.len()
    end
end

impl IndexedGet<T> for Vector<T>:
    fn get(self, i i32) T:
        if i >= self.len():
            panic("Vector index out of bounds")
        end
        return self.data.get(i)
    end
end

impl IndexedSet<T> for Vector<T>:
    fn set(mut self, i i32, v T):
        if i >= self.len():
            panic("Vector index out of bounds")
        end
        self.data.set(i, v)
    end
end

struct VectorIter<T>:
    vec Vector<T>
    index i32
end

impl Iterator<T> for VectorIter<T>:
    fn next(mut self) Option<T>:
        if self.index >= self.vec.len():
            return Option.None
        end
        let value = self.vec.get(self.index)
        self.index = self.index + 1
        return Option.Some(value)
    end
end


