-- Built-in structs, enum, and traits

enum Option<T>:
    None
    Some(T)
end

impl Option<T>:
    fn is_none(self) bool:
        match self:
            None => true
            Some(_) => false
        end
    end

    fn is_some(self) bool:
        match self:
            None => false
            Some(_) => true
        end
    end

    fn unwrap(self) T:
        match self:
            None => panic("called `Option.unwrap()` on a `None` value")
            Some(value) => value
        end
    end

    fn unwrap_or(self, def T) T:
        match self:
            None => def
            Some(value) => value
        end
    end
end

trait ToStr:
    fn to_str(self) str
end

trait Add:
    fn add(self, rhs Self) Self
end

trait Sub:
    fn sub(self, rhs Self) Self
end

trait Mul:
    fn mul(self, rhs Self) Self
end

trait Div:
    fn div(self, rhs Self) Self
end

trait PartialEq:
    fn eq(self, rhs Self) bool
    fn ne(self, rhs Self) bool
end

-- This is just a marker trait. `PartialEq` must be implemented.
trait Eq:
end

trait PartialOrd:
    fn lt(self, rhs Self) bool
    fn le(self, rhs Self) bool
    fn gt(self, rhs Self) bool
    fn ge(self, rhs Self) bool
end

-- This is just a marker trait. `PartialOrd` must be implemented.
trait Ord:
end

trait IndexedGet<K, V>:
    fn get(self, key K) V
end

trait IndexedSet<K, V>:
    fn set(mut self, key K, value V)
end

trait Iterator<T>:
    fn next(self) Option<T>

    fn for_each(self, f (fn(T))):
        loop:
            let next = self.next()
            match next:
                None:
                    break
                end
                Some(value) => f(value)
            end
        end
    end

    fn filter(self, f (fn(T) bool)) Self:
        let vec = Vector<T>.new()
        self.for_each(fn(value T) => if f(value) => vec.push(value))
        vec.iter()
    end

    fn collect(self) Vector<T>:
        let vec = Vector<T>.new()
        self.for_each(fn(value T) => vec.push(value))
        vec
    end
end

trait Len:
    fn len(self) i32
end

struct Error<T=()>:
    msg str
    data T
end

impl Error<T>:
    fn from_str(msg str) Error => Error { msg: msg, data: () }
    fn new(msg str, data T) Error<T> => Error<T> { msg: msg, data: data }
end

impl ToStr for Error<T>:
    fn to_str(self) str => self.msg
end

enum Result<T, E=()>:
    Ok(T)
    Err(Error<E>)
end

impl Result<T, E>:
    fn is_ok(self) bool:
        match self:
            Result.Ok(_) => true
            Result.Err(_) => false
        end
    end

    fn is_err(self) bool:
        match self:
            Result.Ok(_) => false
            Result.Err(_) => true
        end
    end

    fn unwrap(self) T:
        match self:
            Result.Ok(value) => value
            Result.Err(err) => panic(f"called `Result.unwrap()` on an `Err` value: {err.msg}")
        end
    end

    fn unwrap_err(self) Error<E>:
        match self:
            Result.Ok(value) => panic(f"called `Result.unwrap_err()` on an `Ok` value")
            Result.Err(err) => err
        end
    end
end

impl ToStr for Result<T, E>:
    fn to_str(self) str:
        match self:
            Result.Ok(value) => f"Ok()"
            Result.Err(err) => f"Err()"
        end
    end
end

extern:

    fn print(s ToStr)
    fn panic(s str)
    -- For compiler debugging purposes only.
    fn jsprint(s str)

    -- JS array helpers.
    struct JSArray<T>:
    end

    impl JSArray<T>:
        fn new(size i32) Self
        fn len(self) i32
        fn push(mut self, s T) 
        fn get(self, i i32) T
        fn set(mut self, i i32, v T)
    end

    -- File IO.
    struct File:
        path str
    end

    impl File:
        fn at(path str) Self

        fn cwd() Self

        --- Open the file and read its contests as a string.
            Close the file in any case.
        ---
        fn read_str(self) str throws 

        --- Open the file and write the given string to it.
            Close the file in any case.
        ---
        fn write_str(mut self, data str) throws 
    end

    fn ext_args() JSArray<str>
    fn ext_env() JSArray<(str, str)>
end

-- Fixed size array
-- This is an internal data structure used by the compiler. 

struct Array<T>:
    data JSArray<T>
end

impl Array<T>:
    fn new(size i32) Array<T> => Array<T> { data: JSArray<T>.new(size) }
    fn iter(self) ArrayIter<T> => ArrayIter<T> { arr: self, index: 0 }
end

impl Len for Array<T>:
    fn len(self) i32 => self.data.len()
end

impl IndexedGet<i32, T> for Array<T>:
    fn get(self, i i32) T:
        if i >= self.len():
            panic("Array index out of bounds")
        end
        self.data.get(i)
    end
end

impl IndexedSet<i32, T> for Array<T>:
    fn set(mut self, i i32, v T):
        if i >= self.len():
            panic("Array index out of bounds")
        end
        self.data.set(i, v)
    end
end

struct ArrayIter<T>:
    arr Array<T>
    index i32
end

impl Iterator<T> for ArrayIter<T>:
    fn next(mut self) Option<T>:
        if self.index >= self.arr.len():
            return None
        end
        let value = self.arr.get(self.index)
        self.index = self.index + 1
        Some(value)
    end
end

-- Vector

struct Vector<T>:
    data JSArray<T>
end

impl Vector<T>:
    fn new() Vector<T> => Vector<T> { data: JSArray<T>.new(0) }

    fn from(arr Array<T>) Vector<T>:
        let vec = Vector<T>.new()
        mut i = 0
        loop:
            if i >= arr.len():
                break
            end
            let v = arr.get(i)
            vec.push(v)
            i = i + 1
        end
        vec
    end

    fn push(mut self, s T):
        self.data.push(s)
    end

    fn iter(self) VectorIter<T> => VectorIter<T> { vec: self, index: 0 }
end

impl Len for Vector<T>:
    fn len(self) i32 => self.data.len()
end

impl IndexedGet<i32, T> for Vector<T>:
    fn get(self, i i32) T:
        if i >= self.len():
            panic("Vector index out of bounds")
        end
        self.data.get(i)
    end
end

impl IndexedSet<i32, T> for Vector<T>:
    fn set(mut self, i i32, v T):
        if i >= self.len():
            panic("Vector index out of bounds")
        end
        self.data.set(i, v)
    end
end

struct VectorIter<T>:
    vec Vector<T>
    index i32
end

impl Iterator<T> for VectorIter<T>:
    fn next(mut self) Option<T>:
        if self.index >= self.vec.len():
            return None
        end
        let value = self.vec.get(self.index)
        self.index = self.index + 1
        Some(value)
    end
end

-- Map

struct Map<K, V>:
    data Vector<(K, Option<V>)>
end

impl Map<K, V>:
    fn new() Map<K, V> => Map<K, V> { data: Vector<(K, Option<V>)>.new() }
end

impl IndexedGet<K, Option<V>> for Map<K, V>:
    fn get(self, key K) Option<V>:
        mut i = 0
        loop:
            if i >= self.data.len():
                break
            end
            let v = self.data.get(i)
            if v.0 == key:
                return v.1
            end
            i = i + 1
        end
        None
    end
end

impl IndexedSet<K, V> for Map<K, V>:
    fn set(mut self, key K, value V):
        mut i = 0
        loop:
            if i >= self.data.len():
                break
            end
            let v = self.data.get(i)
            if v.0 == key:
                self.data.set(i, (key, Option<V>.Some(value)))
                return
            end
            i = i + 1
        end
        self.data.push((key, Option<V>.Some(value)))
    end
end

impl Len for Map<K, V>:
    fn len(self) i32 => self.data.len()
end

struct Env:
    args Vector<str>
end

impl Env:
    fn new() Env:
        mut i = 0
        let src = ext_args()
        mut args = Vector<str>.new()
        loop:
            if i == src.len():
                break
            end
            let arg = src.get(i)
            args.push(arg)
            i = i + 1
        end
        Env { args: args }
    end
end

let env = Env.new()
