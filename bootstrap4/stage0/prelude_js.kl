-- Built-in structs, enum, and traits

enum Option<T>:
    None
    Some(T)
end

use Option.*

impl Option<T>:
    fn is_none(self) Bool:
        match self:
            None => true
            Some(_) => false
        end
    end

    fn is_some(self) Bool:
        match self:
            None => false
            Some(_) => true
        end
    end

    fn unwrap(self) T:
        match self:
            None => panic("called `Option.unwrap()` on a `None` value")
            Some(value) => value
        end
    end

    fn unwrap_or(self, def T) T:
        match self:
            None => def
            Some(value) => value
        end
    end
end

trait ToStr:
    fn to_str(self) Str
end

trait Add:
    fn add(self, rhs Self) Self
end

trait Sub:
    fn sub(self, rhs Self) Self
end

trait Mul:
    fn mul(self, rhs Self) Self
end

trait Div:
    fn div(self, rhs Self) Self
end

trait PartialEq:
    fn eq(self, rhs Self) Bool
    fn ne(self, rhs Self) Bool => not self.eq(rhs)
end

-- This is just a marker trait. `PartialEq` must be implemented.
trait Eq:
end

trait PartialOrd:
    fn lt(self, rhs Self) Bool
    fn le(self, rhs Self) Bool
    fn gt(self, rhs Self) Bool
    fn ge(self, rhs Self) Bool
end

-- This is just a marker trait. `PartialOrd` must be implemented.
trait Ord:
end

trait IndexedGet<K, V>:
    fn get(self, key K) V
end

trait IndexedSet<K, V>:
    fn set(mut self, key K, value V)
end

trait Iterator<T>:
    fn next(self) Option<T>

    fn for_each(self, f (fn(T))):
        loop:
            match self.next():
                None => break
                Some(value) => f(value)
            end
        end
    end

    fn filter(self, f (fn(T) Bool)) Self:
        let vec = Vector<T>.new()
        self.for_each(fn(value) => if f(value) => vec.push(value))
        vec.iter()
    end

    fn map<U>(self, f (fn(T) U)) Iterator<U>:
        let vec = Vector<U>.new()
        self.for_each(fn(value) => vec.push(f(value)))
        vec.iter()
    end

    fn collect(self) Vector<T>:
        let vec = Vector<T>.new()
        self.for_each(fn(value) => vec.push(value))
        vec
    end

    fn any(self, predicate (fn(T) Bool)) Bool:
        loop:
            match self.next():
                None => return false
                Some(value) => if predicate(value) => break 
            end
        end
        true
    end
end

struct PeekableIterator<T>:
    iter Iterator<T>
    peeked T?
    idx Int
end

impl PeekableIterator<T>:
    fn new(iter Iterator<T>) Self => PeekableIterator<T> { iter, peeked: None, idx: -1 }

    fn peek(mut self) Option<T>:
        if self.peeked.is_some():
            return self.peeked
        end
        self.peeked = self.iter.next()
        self.peeked 
    end
end

impl Iterator<T> for PeekableIterator<T>:
    fn next(mut self) Option<T>:
        self.idx = self.idx + 1
        if self.peeked.is_some():
            let value = self.peeked.unwrap()
            self.peeked = None
            return Some(value)
        end
        self.iter.next()
    end
end

trait Len:
    fn len(self) Int
end

enum Result<T, E impl ToStr=Str>:
    Ok(T)
    Error(E)
end

use Result.*

impl Result<T, E>:
    fn is_ok(self) Bool:
        match self:
            Result.Ok(_) => true
            Result.Error(_) => false
        end
    end

    fn is_error(self) Bool:
        match self:
            Result.Ok(_) => false
            Result.Error(_) => true
        end
    end

    fn unwrap(self) T:
        match self:
            Result.Ok(value) => value
            Result.Error(error) => panic(f"called `Result.unwrap()` on an `Error` value: {error}")
        end
    end

    fn unwrap_error(self) E:
        match self:
            Result.Ok(value) => panic(f"called `Result.unwrap_err()` on an `Ok` value")
            Result.Error(error) => error
        end
    end
end

impl ToStr for Result<T, E>:
    fn to_str(self) Str:
        match self:
            Result.Ok(value) => f"ok: {value}"
            Result.Error(error) => f"error: {error}"
        end
    end
end

extern:

    fn print(s ToStr)
    fn panic(s Str)
    fn exit(code Int)
    fn assert(cond Bool)
    fn register_panic_handler(handler (fn(Str, Str, Str))) (fn(Str, Str, Str))

    -- todo: We should not need this function. We use it to work around
    --       the fact that Klar does not support global variables.
    fn int_next() Int

    impl Len for Str
    impl IndexedGet<Int, Char> for Str
    impl Str:
        fn iter(self) Iterator<Char>
        fn push(mut self, s Str) Str
        fn push_char(mut self, c Char) Str
        fn slice_copy(self, from Int, to Int) Str
        fn join(self, iter Iterator<Str>) Str
    end

    impl Int:
        fn from_str(s Str) Int throws
    end

    -- JS array helpers.
    struct JSArray<T>:
    end

    impl JSArray<T>:
        fn new(size Int) Self
        fn len(self) Int
        fn push(mut self, s T) 
        fn get(self, i Int) T
        fn set(mut self, i Int, v T)
    end

    -- File IO.
    struct File:
        path Str
    end

    impl File:
        fn at(path Str) Self

        fn cwd() Self

        --- Open the file and read its contests as a string.
            Close the file in any case.
        ---
        fn read_str(self) Str throws 

        --- Open the file and write the given string to it.
            Close the file in any case.
        ---
        fn write_str(mut self, data Str) throws 
    end

    fn ext_args() JSArray<Str>
    fn ext_env() JSArray<(Str, Str)>
end

impl Str:
    fn repeat(self, n Int) Str:
        mut s = ""
        mut i = 0
        loop:
            if i >= n => break
            s.push(self)
            i = i + 1
        end
        s
    end

    fn replace(self, from Str, to Str) Str:
        mut s = ""
        mut i = 0
        mut cur_match = ""
        loop:
            if i >= self.len() => break
            let c = self[i]
            if c == from[cur_match.len()]:
                cur_match.push_char(c)
                if cur_match == from:
                    s.push(to)
                    cur_match = ""
                end
            else:
                s.push(cur_match)
                s.push_char(c)
                cur_match = ""
            end
            i = i + 1
        end
        s
    end

    fn when(self, condition Bool) Str:
        --- Returns `self` if the condition is met, otherwise an empty string.
            This is useful in f-strings to insert a space only if a condition is met.
        ---
        if condition => self else => ""
    end
end

-- Fixed size array
-- This is an internal data structure used by the compiler. 

struct Array<T>:
    data JSArray<T>
end

impl Array<T>:
    fn new(size Int) Array<T> => Array<T> { data: JSArray<T>.new(size) }
    fn iter(self) ArrayIter<T> => ArrayIter<T> { arr: self, index: 0 }
end

impl Len for Array<T>:
    fn len(self) Int => self.data.len()
end

impl IndexedGet<Int, T> for Array<T>:
    fn get(self, i Int) T:
        if i >= self.len():
            panic("Array index out of bounds")
        end
        self.data.get(i)
    end
end

impl IndexedSet<Int, T> for Array<T>:
    fn set(mut self, i Int, v T):
        if i >= self.len():
            panic("Array index out of bounds")
        end
        self.data.set(i, v)
    end
end

struct ArrayIter<T>:
    arr Array<T>
    index Int
end

impl Iterator<T> for ArrayIter<T>:
    fn next(mut self) Option<T>:
        if self.index >= self.arr.len():
            return None
        end
        let value = self.arr.get(self.index)
        self.index = self.index + 1
        Some(value)
    end
end

-- Vector

struct Vector<T>:
    data JSArray<T>
end

impl Vector<T>:
    fn new() Vector<T> => Vector<T> { data: JSArray<T>.new(0) }

    fn from(arr Array<T>) Vector<T>:
        let vec = Vector<T>.new()
        mut i = 0
        loop:
            if i >= arr.len():
                break
            end
            let v = arr.get(i)
            vec.push(v)
            i = i + 1
        end
        vec
    end

    fn push(mut self, s T):
        self.data.push(s)
    end

    fn iter(self) VectorIter<T> => VectorIter<T> { vec: self, index: 0 }

    fn slice_copy(self, from Int, to Int) Vector<T>:
        let vec = Vector<T>.new()
        mut i = from
        loop:
            if i >= to => break
            vec.push(self[i])
            i = i + 1
        end
        vec
    end
end

impl Len for Vector<T>:
    fn len(self) Int => self.data.len()
end

impl PartialEq for Vector<T>:
    fn eq(self, rhs Vector<T>) Bool:
        if self.len() != rhs.len() => return false
        mut i = 0
        loop:
            if i >= self.len() => break
            if self[i] != rhs[i] => return false
            i = i + 1
        end
        true
    end
end

impl IndexedGet<Int, T> for Vector<T>:
    fn get(self, i Int) T:
        if i >= self.len():
            panic("Vector index out of bounds")
        end
        self.data.get(i)
    end
end

impl IndexedSet<Int, T> for Vector<T>:
    fn set(mut self, i Int, v T):
        if i >= self.len():
            panic("Vector index out of bounds")
        end
        self.data.set(i, v)
    end
end

struct VectorIter<T>:
    vec Vector<T>
    index Int
end

impl Iterator<T> for VectorIter<T>:
    fn next(mut self) Option<T>:
        if self.index >= self.vec.len():
            return None
        end
        let value = self.vec.get(self.index)
        self.index = self.index + 1
        Some(value)
    end
end

-- Map

struct Map<K, V>:
    data Vector<(K, Option<V>)>
end

impl Map<K, V>:
    fn new() Map<K, V> => Map<K, V> { data: Vector<(K, Option<V>)>.new() }
end

impl IndexedGet<K, Option<V>> for Map<K, V>:
    fn get(self, key K) Option<V>:
        mut i = 0
        loop:
            if i >= self.data.len():
                break
            end
            let v = self.data.get(i)
            if v.0 == key:
                return v.1
            end
            i = i + 1
        end
        None
    end
end

impl IndexedSet<K, V> for Map<K, V>:
    fn set(mut self, key K, value V):
        mut i = 0
        loop:
            if i >= self.data.len():
                break
            end
            let v = self.data.get(i)
            if v.0 == key:
                self.data.set(i, (key, Option<V>.Some(value)))
                return
            end
            i = i + 1
        end
        self.data.push((key, Option<V>.Some(value)))
    end
end

impl Len for Map<K, V>:
    fn len(self) Int => self.data.len()
end

struct Env:
    args Vector<Str>
end

impl Env:
    fn new() Env:
        mut i = 0
        let src = ext_args()
        mut args = Vector<Str>.new()
        loop:
            if i == src.len():
                break
            end
            let arg = src.get(i)
            args.push(arg)
            i = i + 1
        end
        Env{args}
    end
end

let env = Env.new()
