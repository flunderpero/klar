-- Built-in structs, enum, and traits

enum Option<T>:
    None
    Some(T)
end

trait ToStr:
    fn to_str(self) str
end

trait Add:
    fn add(self, rhs Self) Self
end

trait Sub:
    fn sub(self, rhs Self) Self
end

trait Mul:
    fn mul(self, rhs Self) Self
end

trait Div:
    fn div(self, rhs Self) Self
end

trait PartialEq:
    fn eq(self, rhs Self) bool
    fn ne(self, rhs Self) bool
end

-- This is just a marker trait. `PartialEq` must be implemented.
trait Eq:
end

trait PartialOrd:
    fn lt(self, rhs Self) bool
    fn le(self, rhs Self) bool
    fn gt(self, rhs Self) bool
    fn ge(self, rhs Self) bool
end

-- This is just a marker trait. `PartialOrd` must be implemented.
trait Ord:
end

trait IndexedGet<T>:
    fn get(self, i i32) T
end

trait IndexedSet<T>:
    fn set(mut self, i i32, v T)
end

trait Iterator<T>:
    fn next(self) T

    fn for_each(self, f (fn(T))):
        loop:
            let next = self.next()
            match next:
                Option.None :
                    break
                end
                Option.Some(value) => f(value)
            end
        end
    end

    fn filter(self, f (fn(T) bool)) Self:
        let vec = Vector<T>.new()
        self.for_each(fn(value) => if f(value) => vec.push(value))
        return vec.iter()
    end

    fn collect(self) Vector<T>:
        let vec = Vector<T>.new()
        self.for_each(fn(value) => vec.push(value))
        return vec
    end
end

trait Len:
    fn len(self) i32
end

extern:

    fn print(s ToStr)
    fn panic(s str)
    -- For compiler debugging purposes only.
    fn jsprint(s str)

    -- JS array helpers.
    struct JSArray<T>:
    end

    impl JSArray<T>:
        fn new() Self
        fn len(self) i32
        fn push(mut self, s T) 
        fn get(self, i i32) T
        fn set(mut self, i i32, v T)
    end
end

-- Fixed size array
-- This is an internal data structure used by the compiler. 
-- TODO: Don't expose this to the user.

struct array<A>:
    data JSArray<A>
end

impl array<T>:
    fn new(size i32) array<T>:
        return array { data: JSArray<T>.new(size) }
    end

    fn iter(self) ArrayIter<T>:
        return ArrayIter<T> { arr: self, index: 0 }
    end
end

impl Len for array<T>:
    fn len(self) i32:
        return self.data.len()
    end
end

impl IndexedGet<T> for array<T>:
    fn get(self, i i32) T:
        if i >= self.len():
            panic("Array index out of bounds")
        end
        return self.data.get(i)
    end
end

impl IndexedSet<T> for array<T>:
    fn set(mut self, i i32, v T):
        if i >= self.len():
            panic("Array index out of bounds")
        end
        self.data.set(i, v)
    end
end

struct ArrayIter<T>:
    arr array<T>
    index i32
end

impl Iterator<T> for ArrayIter<T>:
    fn next(mut self) Option<T>:
        if self.index >= self.arr.len():
            return Option.None
        end
        let value = self.arr.get(self.index)
        self.index = self.index + 1
        return Option.Some(value)
    end
end

-- Vector

struct Vector<T>:
    data JSArray<T>
end

impl Vector<T>:
    fn new() Vector<T>:
        return Vector { data: JSArray<T>.new(0) }
    end

    fn from(arr array<T>) Vector<T>:
        let vec = Vector<T>.new()
        mut i = 0
        loop:
            if i >= arr.len():
                break
            end
            vec.push(arr.get(i))
            i = i + 1
        end
        return vec
    end

    fn push(mut self, s T):
        self.data.push(s)
    end

    fn iter(self) VectorIter<T>:
        return VectorIter<T> { vec: self, index: 0 }
    end
end

impl Len for Vector<T>:
    fn len(self) i32:
        return self.data.len()
    end
end

impl IndexedGet<T> for Vector<T>:
    fn get(self, i i32) T:
        if i >= self.len():
            panic("Vector index out of bounds")
        end
        return self.data.get(i)
    end
end

impl IndexedSet<T> for Vector<T>:
    fn set(mut self, i i32, v T):
        if i >= self.len():
            panic("Vector index out of bounds")
        end
        self.data.set(i, v)
    end
end

struct VectorIter<T>:
    vec Vector<T>
    index i32
end

impl Iterator<T> for VectorIter<T>:
    fn next(mut self) Option<T>:
        if self.index >= self.vec.len():
            return Option.None
        end
        let value = self.vec.get(self.index)
        self.index = self.index + 1
        return Option.Some(value)
    end
end


