use .lexer::Span
use .lexer::Token

trait ToDebugStr:
    --- Convert the item to a string representation that does retain
        all information, but is easier to test / reason about.
    ---
    fn to_debug_str(self) Str

    fn to_debug_str_multiline(self) Str:
        --- Same as `to_debug_str`, but with newlines and indentation.
        ---
        let str = self.to_debug_str()
        mut res = ""
        mut indent = 0
        mut iter = str.iter()
        loop:
            match iter.next():
                Some('('):
                    if res.len() > 0:
                        res.push("\n")
                    end
                    res.push("  ".repeat(indent))
                    res.push("(")
                    indent = indent + 1
                end
                Some(')'):
                    indent = indent - 1
                    res.push(")")
                end
                Some(x) => res.push_char(x)
                None => break
            end
        end
        res
    end
end

enum ParseErrorKind:
    CharLiteralExpected(Token)
    ExprExpected(Token)
    IdentExpected(Token)
    IntLiteralExpected(Token)
    InvalidIntLiteral(Token)
    PatternExpected(Token)
    ParamExpected(Token)
    TypeExpected(Token)
    UnexpectedEOF
    UnexpectedFnDecl(FnDecl)
    UnexpectedToken(Token)
end

struct ParseError:
    kind ParseErrorKind
    meta Meta
end

enum LiteralKind:
    IntLiteral(Int)
    BoolLiteral(Bool)
    StrLiteral(Str)
    CharLiteral(Char)
    UnitLiteral
end

struct Literal:
    kind LiteralKind
    meta Meta
end

struct Call:
    target Expr
    args Vector<Expr>
    meta Meta
end

struct Ident:
    name Str
    meta Meta
end

struct FStr:
    exprs Vector<Expr>
    meta Meta
end

enum BinaryExprKind:
    Add
    And
    Div
    Equal
    GreaterThan
    GreaterThanOrEqual
    LessThan
    LessThanOrEqual
    Mul
    NotEqual
    Or
    Sub
end

struct BinaryExpr:
    lhs Expr
    rhs Expr
    kind BinaryExprKind
    meta Meta
end

enum UnaryExprKind:
    Neg
    Not
end

struct UnaryExpr:
    expr Expr
    kind UnaryExprKind
    meta Meta
end

struct Assignment:
    lhs Expr
    rhs Expr
    meta Meta
end

struct Let:
    ident Ident
    is_mut Bool
    type_ Type
    expr Expr
    meta Meta
end

struct If:
    cond Expr
    then_block Block
    else_block Block?
    meta Meta
end

struct Loop:
    body Block
    meta Meta
end

struct Break:
    meta Meta
end

struct Continue:
    meta Meta
end

struct Return:
    expr Expr
    meta Meta
end

struct FieldAccess:
    target Expr
    field Ident
    meta Meta
end

struct Match:
    expr Expr
    arms Vector<MatchArm>
    meta Meta
end

struct MatchArm:
    pattern Pattern
    block Block
    meta Meta
end

struct Pattern:
    kind PatternKind
    meta Meta
end

struct Range:
    start Literal
    end_ Literal
    end_is_exclusive Bool
    meta Meta
end

enum PatternKind:
    EnumVariant(FQN, Vector<Pattern>)
    Ident(Ident)
    FQN(FQN)
    Literal(Literal)
    Or(Vector<Pattern>)
    Range(Range)
    Struct(FQN, Vector<(Ident, Pattern)>)
    Tuple(Vector<Pattern>)
    Wildcard
end

struct StructInst:
    fqn FQN
    generics Vector<GenericArg>?
    fields Vector<(Ident, Expr)>
    meta Meta
end

enum Expr:
    Assignment(Assignment)
    BinaryExpr(BinaryExpr)
    Break(Break)
    Call(Call)
    Continue(Continue)
    FQN(FQN)
    FStr(FStr)
    FieldAccess(FieldAccess)
    Ident(Ident)
    If(If)
    Let(Let)
    Literal(Literal)
    Loop(Loop)
    Match(Match)
    Return(Return)
    StructInst(StructInst)
    UnaryExpr(UnaryExpr)
end

struct GenericArg:
    type_ Type
    meta Meta
end

struct Name:
    ident Ident
    generics Vector<GenericArg>?
    meta Meta
end

struct FQN:
    --- A fully qualified name is a series of names, separated by `::`.
        A name can have generic arguments.
        Example: `module::Enum::Variant<T>`.
    ---
    names Vector<Name>
    meta Meta
end

enum TypeKind:
    FQN(FQN)
    Infer
    Self
    Unit
end

struct Type:
    kind TypeKind
    meta Meta
end

struct Param:
    ident Ident
    type_ Type
    meta Meta
end

struct FnDecl:
    ident Ident
    params Vector<Param>
    return_type Type
    meta Meta
end

struct Fn:
    decl FnDecl
    body Block
    meta Meta
end

struct Block:
    items Vector<BlockItem>
    meta Meta
end

struct Trait:
    name Name
    fn_decls Vector<FnDecl>
    fn_impls Vector<Fn>
    meta Meta
end

enum EnumVariantKind:
    Tuple(Vector<Type>)
    Unit
end

struct EnumVariant:
    ident Ident
    kind EnumVariantKind
    meta Meta
end

struct Enum:
    name Name
    variants Vector<EnumVariant>
    meta Meta
end

struct Struct:
    name Name
    fields Vector<Field>
    meta Meta
end

struct Field:
    ident Ident
    type_ Type
    meta Meta
end

struct Impl:
    -- todo (lang feat): Make `type` a reserved word for future use.
    type_ FQN
    trait_ FQN?
    fn_impls Vector<Fn>
    meta Meta
end

struct Extern:
    items Vector<ExternItem>
    meta Meta
end

enum ExternItem:
    Enum(Enum)
    ExternImpl(ExternImpl)
    ExternImplTrait(ExternImplTrait)
    FnDecl(FnDecl)
    Struct(Struct)
end

struct ExternImpl:
    type_ FQN
    fn_decls Vector<FnDecl>
    meta Meta
end

struct ExternImplTrait:
    type_ FQN
    trait_ FQN
    meta Meta
end

enum BlockItem:
    Struct(Struct)
    Enum(Enum)
    Expr(Expr)
    Fn(Fn)
    Impl(Impl)
    Trait(Trait)
end

enum ModuleItem:
    Extern(Extern)
    -- Use(Use)
    Struct(Struct)
    Enum(Enum)
    Fn(Fn)
    Impl(Impl)
    Trait(Trait)
end

struct Module:
    items Vector<ModuleItem>
    meta Meta
end

struct Id:
    --- Each item in the AST is assigned a unique ID. 
    ---
    -- todo (lang-feat): This should be private.
    id Int
end

struct Meta:
    id Id
    --- The tokens taken from the source code. These tokens never
        change even if the item is desugared.
    ---
    tokens Vector<Token>
end

impl Meta:
    fn new(tokens Vector<Token>) Meta:
        let id = Id{id: int_next()} 
        Meta{id: id, tokens}
    end

    fn span(self) Span:
        let last = self.tokens.len() - 1
        -- todo (lang-feat): We should be able to just use `-1` as the end index.
        self.tokens[0].span.combine(self.tokens[last].span)
    end
end

impl ToDebugStr for Meta:
    fn to_debug_str(self) Str:
        f"(@meta {self.id.id} {self.span()})"
    end
end

impl ToDebugStr for Name:
    fn to_debug_str(self) Str:
        let generics = match self.generics:
            Some(x) => 
                " ".join(
                    x.iter().map<Str>(fn(it GenericArg) Str => it.type_.to_debug_str())
                )
            None => ""
        end
        f"(@name {self.ident.to_debug_str()}{" ".when(generics.len() > 0)}{generics})"
    end
end

impl ToDebugStr for FQN:
    fn to_debug_str(self) Str:
        let names = " ".join(
            self.names.iter().map<Str>(fn(it Name) Str => it.to_debug_str())
        )
        f"(@fqn {names})"
    end
end

impl ToDebugStr for Type:
    fn to_debug_str(self) Str:
        match self.kind:
            TypeKind::FQN(x) => f"(@type {x.to_debug_str()})"
            TypeKind::Unit => "(@type (@unit))"
            TypeKind::Self => "(@type (@self))"
            TypeKind::Infer => "(@type (@infer))"
        end
    end
end

impl ToDebugStr for Param:
    fn to_debug_str(self) Str => f"(@param {self.ident.to_debug_str()} {self.type_.to_debug_str()})"
end

impl ToDebugStr for FnDecl:
    fn to_debug_str(self) Str:
        let params = " ".join(
            self.params.iter().map<Str>(fn(it Param) Str => it.to_debug_str())
        )
        let return_type = self.return_type.to_debug_str()
        f"(@fndecl {self.ident.to_debug_str()}{" ".when(params.len() > 0)}{params} {return_type})"
    end
end

impl ToDebugStr for Trait:
    fn to_debug_str(self) Str:
        let fn_decls = " ".join(
            self.fn_decls.iter().map<Str>(fn(it FnDecl) Str => it.to_debug_str())
        )
        let fn_impls = " ".join(
            self.fn_impls.iter().map<Str>(fn(it Fn) Str => it.to_debug_str())
        )
        f"(@trait {self.name.to_debug_str()}{" ".when(fn_decls.len() > 0)}{fn_decls}{" ".when(fn_impls.len() > 0)}{fn_impls})"
    end
end

impl ToDebugStr for EnumVariantKind:
    fn to_debug_str(self) Str:
        match self:
            EnumVariantKind::Tuple(x):
                let types = " ".join(
                    x.iter().map<Str>(fn(it Type) Str => it.to_debug_str())
                )
                f"(@tuple {types})"
            end
            EnumVariantKind::Unit => "(@unit)"
        end
    end
end

impl ToDebugStr for EnumVariant:
    fn to_debug_str(self) Str:
        let kind = self.kind.to_debug_str()
        f"(@variant {self.ident.to_debug_str()} {kind})"
    end
end

impl ToDebugStr for Enum:
    fn to_debug_str(self) Str:
        let variants = " ".join(
            self.variants.iter().map<Str>(fn(it EnumVariant) Str => it.to_debug_str())
        )
        f"(@enum {self.name.to_debug_str()}{" ".when(variants.len() > 0)}{variants})"
    end
end

impl ToDebugStr for Field:
    fn to_debug_str(self) Str => f"(@field {self.ident.to_debug_str()} {self.type_.to_debug_str()})"
end

impl ToDebugStr for Struct:
    fn to_debug_str(self) Str:
        let fields = " ".join(
            self.fields.iter().map<Str>(fn(it Field) Str => it.to_debug_str())
        )
        f"(@struct {self.name.to_debug_str()}{" ".when(fields.len() > 0)}{fields})"
    end
end

impl ToDebugStr for Impl:
    fn to_debug_str(self) Str:
        let trait_ = match self.trait_:
            Some(x) => f"{x.to_debug_str()} "
            None => ""
        end
        let fn_impls = " ".join(
            self.fn_impls.iter().map<Str>(fn(it Fn) Str => it.to_debug_str())
        )
        f"(@impl {trait_}{self.type_.to_debug_str()}{" ".when(fn_impls.len() > 0)}{fn_impls})"
    end
end

impl ToDebugStr for Extern:
    fn to_debug_str(self) Str:
        let items = " ".join(
            self.items.iter().map<Str>(fn(it ExternItem) Str => it.to_debug_str())
        )
        f"(@extern{" ".when(items.len() > 0)}{items})"
    end
end

impl ToDebugStr for ExternImpl:
    fn to_debug_str(self) Str:
        let fn_decls = " ".join(
            self.fn_decls.iter().map<Str>(fn(it FnDecl) Str => it.to_debug_str())
        )
        f"(@externimpl {self.type_.to_debug_str()}{" ".when(fn_decls.len() > 0)}{fn_decls})"
    end
end

impl ToDebugStr for ExternImplTrait:
    fn to_debug_str(self) Str:
        f"(@externimpltrait {self.trait_.to_debug_str()} {self.type_.to_debug_str()})"
    end
end

impl ToDebugStr for ExternItem:
    fn to_debug_str(self) Str:
        match self:
            ExternItem::Enum(x) => x.to_debug_str()
            ExternItem::FnDecl(x) => x.to_debug_str()
            ExternItem::ExternImpl(x) => x.to_debug_str()
            ExternItem::ExternImplTrait(x) => x.to_debug_str()
            ExternItem::Struct(x) => x.to_debug_str()
        end
    end
end

impl ToDebugStr for ModuleItem:
    fn to_debug_str(self) Str:
        match self:
            ModuleItem::Enum(x) => x.to_debug_str()
            ModuleItem::Extern(x) => x.to_debug_str()
            ModuleItem::Fn(x) => x.to_debug_str()
            ModuleItem::Impl(x) => x.to_debug_str()
            ModuleItem::Trait(x) => x.to_debug_str()
            ModuleItem::Struct(x) => x.to_debug_str()
        end
    end
end

impl ToDebugStr for Module:
    fn to_debug_str(self) Str:
        let items = " ".join(
            self.items.iter().map<Str>(fn(it ModuleItem) Str => it.to_debug_str())
        )
        f"(@mod{" ".when(items.len() > 0)}{items})"
    end
end

impl ToDebugStr for BlockItem:
    fn to_debug_str(self) Str:
        match self:
            BlockItem::Enum(x) => x.to_debug_str()
            BlockItem::Expr(x) => x.to_debug_str()
            BlockItem::Fn(x) => x.to_debug_str()
            BlockItem::Impl(x) => x.to_debug_str()
            BlockItem::Trait(x) => x.to_debug_str()
            BlockItem::Struct(x) => x.to_debug_str()
        end
    end
end

impl ToDebugStr for Fn:
    fn to_debug_str(self) Str:
        let body = self.body.to_debug_str()
        let decl = self.decl.to_debug_str()
        f"(@fn {decl} {body})"
    end
end

impl ToDebugStr for Block:
    fn to_debug_str(self) Str:
        if self.items.len() == 0 => return "(@block)"
        let body = " ".join(
            self.items.iter().map<Str>(fn(it BlockItem) Str => it.to_debug_str())
        )
        f"(@block {body})"
    end
end

impl ToDebugStr for ParseErrorKind:
    fn to_debug_str(self) Str:
        match self:
            ParseErrorKind::CharLiteralExpected(token) => f"(@error char literal expected at {token.span})"
            ParseErrorKind::ExprExpected(token) => f"(@error expr expected at {token.span})"
            ParseErrorKind::IdentExpected(token) => f"(@error ident expected at {token.span})"
            ParseErrorKind::IntLiteralExpected(token) => f"(@error int literal expected at {token.span})"
            ParseErrorKind::InvalidIntLiteral(token) => f"(@error invalid int literal at {token.span})"
            ParseErrorKind::ParamExpected(token) => f"(@error param expected at {token.span})"
            ParseErrorKind::PatternExpected(token) => f"(@error pattern expected at {token.span})"
            ParseErrorKind::TypeExpected(token) => f"(@error type expected at {token.span})"
            ParseErrorKind::UnexpectedEOF => "(@error eof)"
            ParseErrorKind::UnexpectedFnDecl(decl) => f"(@error unexpected fn decl `{decl.ident}` at {decl.meta.span()})"
            ParseErrorKind::UnexpectedToken(token) => f"(@error unexpected token `{token}` at {token.span})"
        end
    end
end

impl ToDebugStr for Literal:
    fn to_debug_str(self) Str:
        let lit = match self.kind:
            LiteralKind::BoolLiteral(value) => f"(@bool {value})"
            LiteralKind::CharLiteral(value) => f"(@char {value})"
            LiteralKind::IntLiteral(value) => f"(@int {value})"
            LiteralKind::StrLiteral(value) => f"(@str{" ".when(value.len() > 0)}{value.replace("\n", "\\n")})"
            LiteralKind::UnitLiteral=> "(@unit)"
        end
        f"{lit}"
    end
end

impl ToDebugStr for Call:
    fn to_debug_str(self) Str:
        let args = " ".join(
            self.args.iter().map<Str>(fn(it Expr) Str => it.to_debug_str())
        )
        f"(@call {self.target.to_debug_str()}{" ".when(args.len() > 0)}{args})"
    end
end

impl ToDebugStr for Ident:
    fn to_debug_str(self) Str => f"(@ident {self.name})"
end

impl ToStr for Ident:
    fn to_str(self) Str => self.name
end

impl ToDebugStr for FStr:
    fn to_debug_str(self) Str:
        let exprs = " ".join(
            self.exprs.iter().map<Str>(fn(it Expr) Str => it.to_debug_str())
        )
        f"(@fstr{" ".when(exprs.len() > 0)}{exprs})"
    end
end

impl ToDebugStr for BinaryExpr:
    fn to_debug_str(self) Str:
        let kind = match self.kind:
            BinaryExprKind::Add => "+"
            BinaryExprKind::And => "and"
            BinaryExprKind::Div => "/"
            BinaryExprKind::Equal => "=="
            BinaryExprKind::GreaterThan => ">"
            BinaryExprKind::GreaterThanOrEqual => ">="
            BinaryExprKind::LessThan => "<"
            BinaryExprKind::LessThanOrEqual => "<="
            BinaryExprKind::Mul => "*"
            BinaryExprKind::NotEqual => "!="
            BinaryExprKind::Or => "or"
            BinaryExprKind::Sub => "-"
        end
        f"(@binexpr {kind} {self.lhs.to_debug_str()} {self.rhs.to_debug_str()})"
    end
end

impl ToDebugStr for Assignment:
    fn to_debug_str(self) Str => f"(@assign {self.lhs.to_debug_str()} {self.rhs.to_debug_str()})"
end

impl ToDebugStr for Let:
    fn to_debug_str(self) Str:
        let name = if self.is_mut => "mut" else => "let"
        f"(@{name} {self.ident.to_debug_str()} {self.type_.to_debug_str()} {self.expr.to_debug_str()})"
    end
end

impl ToDebugStr for If:
    fn to_debug_str(self) Str:
        let else_block = match self.else_block:
            Some(x) => f" {x.to_debug_str()}"
            None => ""
        end
        f"(@if {self.cond.to_debug_str()} {self.then_block.to_debug_str()}{else_block})"
    end
end

impl ToDebugStr for UnaryExpr:
    fn to_debug_str(self) Str:
        let kind = match self.kind:
            UnaryExprKind::Neg => "-"
            UnaryExprKind::Not => "not"
        end
        f"(@unexpr {kind} {self.expr.to_debug_str()})"
    end
end

impl ToDebugStr for Loop:
    fn to_debug_str(self) Str => f"(@loop {self.body.to_debug_str()})"
end

impl ToDebugStr for Break:
    fn to_debug_str(self) Str => "(@break)"
end

impl ToDebugStr for Continue:
    fn to_debug_str(self) Str => "(@continue)"
end

impl ToDebugStr for Return:
    fn to_debug_str(self) Str => f"(@return {self.expr.to_debug_str()})"
end

impl ToDebugStr for FieldAccess:
    fn to_debug_str(self) Str 
        => f"(@fieldaccess {self.target.to_debug_str()} {self.field.to_debug_str()})"
end

impl ToDebugStr for MatchArm:
    fn to_debug_str(self) Str
        => f"(@matcharm {self.pattern.to_debug_str()} {self.block.to_debug_str()})"
end

impl ToDebugStr for Range:
    fn to_debug_str(self) Str:
        let sign = if self.end_is_exclusive => "..<" else => ".."
        f"(@range {self.start.to_debug_str()} {sign} {self.end_.to_debug_str()})"
    end
end

impl ToDebugStr for PatternKind:
    fn to_debug_str(self) Str:
        match self:
            PatternKind::EnumVariant(fqn, patterns):
                let patterns_str = " ".join(
                    patterns.iter().map<Str>(fn(it Pattern) Str => it.to_debug_str())
                )
                f"(@enumvariant {fqn.to_debug_str()}{" ".when(patterns_str.len() > 0)}{patterns_str})"
            end
            PatternKind::Struct(fqn, fields):
                let fields_str = " ".join(
                    fields.iter().map<Str>(fn(it (Ident, Pattern)) Str 
                        => f"(@field {it.0.to_debug_str()} {it.1.to_debug_str()})")
                )
                f"(@struct {fqn.to_debug_str()}{" ".when(fields_str.len() > 0)}{fields_str})"
            end
            PatternKind::Or(patterns):
                let patterns_str = " ".join(
                    patterns.iter().map<Str>(fn(it Pattern) Str => it.to_debug_str())
                )
                f"(@or {patterns_str})"
            end
            PatternKind::Ident(x) => x.to_debug_str()
            PatternKind::FQN(x) => x.to_debug_str()
            PatternKind::Literal(x) => f"(@literal {x.to_debug_str()})"
            PatternKind::Range(x) => x.to_debug_str()
            PatternKind::Tuple(x):
                let patterns = " ".join(
                    x.iter().map<Str>(fn(it Pattern) Str => it.to_debug_str())
                )
                f"(@tuple{" ".when(patterns.len() > 0)}{patterns})"
            end
            PatternKind::Wildcard => "(@wildcard)"
        end
    end
end

impl ToDebugStr for Pattern:
    fn to_debug_str(self) Str => f"(@pattern {self.kind.to_debug_str()})"
end

impl ToDebugStr for Match:
    fn to_debug_str(self) Str:
        let arms = " ".join(
            self.arms.iter().map<Str>(fn(it MatchArm) Str => it.to_debug_str())
        )
        f"(@match {self.expr.to_debug_str()}{" ".when(arms.len() > 0)}{arms})"
    end
end

impl ToDebugStr for StructInst:
    fn to_debug_str(self) Str:
        let generics = match self.generics:
            Some(x) => 
                " ".join(
                    x.iter().map<Str>(fn(it GenericArg) Str => it.type_.to_debug_str())
                )
            None => ""
        end
        let fields = " ".join(
            self.fields.iter().map<Str>(fn(it (Ident, Expr)) Str 
                => f"(@field {it.0.to_debug_str()} {it.1.to_debug_str()})")
        )
        f"(@structinst {self.fqn.to_debug_str()}{" ".when(generics.len() > 0)}{generics}{" ".when(fields.len() > 0)}{fields})"
    end
end

impl ToDebugStr for Expr:
    fn to_debug_str(self) Str:
        match self:
            Expr::Assignment(value) => value.to_debug_str()
            Expr::BinaryExpr(value) => value.to_debug_str()
            Expr::Break(value) => value.to_debug_str()
            Expr::Call(value) => value.to_debug_str()
            Expr::Continue(value) => value.to_debug_str()
            Expr::FieldAccess(value) => value.to_debug_str()
            Expr::FStr(value) => value.to_debug_str()
            Expr::FQN(value) => value.to_debug_str()
            Expr::Ident(value) => value.to_debug_str()
            Expr::If(value) => value.to_debug_str()
            Expr::Let(value) => value.to_debug_str()
            Expr::Literal(value) => value.to_debug_str()
            Expr::Loop(value) => value.to_debug_str()
            Expr::Match(value) => value.to_debug_str()
            Expr::Return(value) => value.to_debug_str()
            Expr::StructInst(value) => value.to_debug_str()
            Expr::UnaryExpr(value) => value.to_debug_str()
        end
    end
end

impl ToDebugStr for ParseError:
    fn to_debug_str(self) Str => self.kind.to_debug_str()
end

impl ToStr for ParseError:
    fn to_str(self) Str => self.to_debug_str()
end
