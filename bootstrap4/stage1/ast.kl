use .lexer.Token

trait ToDebugStr:
    --- Convert the item to a string representation that does retain
        all information, but is easier to test / reason about.
    ---
    fn to_debug_str(self) Str
end

enum ParseErrorKind:
    UnexpectedToken(Token)
    UnexpectedEOF
    InvalidIntLiteral(Token)
    ExprExpected(Token)
    IdentExpected(Token)
end

struct ParseError:
    kind ParseErrorKind
    meta Meta
end

enum LiteralKind:
    IntLiteral(Int)
    BoolLiteral(Bool)
    StrLiteral(Str)
    UnitLiteral
end

struct Literal:
    kind LiteralKind
    meta Meta
end

struct Call:
    target Expr
    args Vector<Expr>
    meta Meta
end

struct Ident:
    name Str
    meta Meta
end

struct FStr:
    exprs Vector<Expr>
    meta Meta
end

enum BinaryExprKind:
    Add
    And
    Div
    Equal
    GreaterThan
    GreaterThanOrEqual
    LessThan
    LessThanOrEqual
    Mul
    NotEqual
    Or
    Sub
end

struct BinaryExpr:
    lhs Expr
    rhs Expr
    kind BinaryExprKind
    meta Meta
end

struct Assignment:
    lhs Expr
    rhs Expr
    meta Meta
end

enum Expr:
    Assignment(Assignment)
    BinaryExpr(BinaryExpr)
    Call(Call)
    FStr(FStr)
    Ident(Ident)
    Literal(Literal)
end

struct GenericArg:
    type Type
    meta Meta
end

struct NameSegment:
    ident Ident
    args Vector<GenericArg>?
    meta Meta
end

struct Name:
    --- A name is a series of segments, separated by `.`.
        A segment can have generic arguments.
        Example: `module.Enum<T>.Variant`.
    ---
    segments Vector<NameSegment>
    meta Meta
end

enum TypeKind:
    Name(Name)
    Unit
end

struct Type:
    kind TypeKind
    meta Meta
end

struct Param:
    ident Ident
    type Type
    meta Meta
end

struct FnDecl:
    ident Ident
    params Vector<Param>
    return_type Type
    meta Meta
end

struct Fn:
    decl FnDecl
    body Block
    meta Meta
end

struct Block:
    items Vector<BlockItem>
    meta Meta
end

enum BlockItem:
    Expr(Expr)
    Fn(Fn)
    -- Enum(Enum)
    -- Impl(Impl)
    -- Struct(Struct)
    -- Trait(Trait)
end

enum ModuleItem:
    Fn(Fn)
    -- Use(Use)
    -- Extern(Extern)
    -- Enum(Enum)
    -- Impl(Impl)
    -- Struct(Struct)
    -- Trait(Trait)
end

struct Module:
    items Vector<ModuleItem>
    meta Meta
end

struct Id:
    --- Each item in the AST is assigned a unique ID. 
    ---
    -- todo (lang-feat): This should be private.
    id Int
end

struct Meta:
    id Id
    --- The tokens taken from the source code. These tokens never
        change even if the item is desugared.
    ---
    tokens Vector<Token>
    --- Whether this item has been altered by the parser as part
        of desugaring.
    ---
    is_synthetic Bool
end

impl Meta:
    fn new(tokens Vector<Token>, is_synthetic Bool) Meta:
        let id = Id{id: int_next()} 
        Meta{id: id, tokens: tokens, is_synthetic: is_synthetic}
    end
end

impl ToDebugStr for Meta:
    fn to_debug_str(self) Str:
        if self.is_synthetic => ":syn"
        else => ""
    end
end

impl ToDebugStr for NameSegment:
    fn to_debug_str(self) Str:
        let args = match self.args:
            Some(args) => " ".join(
                args.iter().map<Str>(fn(it GenericArg) Str => it.type.to_debug_str())
            )
            None => ""
        end
        f"(@seg {self.ident.to_debug_str()}{self.meta.to_debug_str()}{args})"
    end
end

impl ToDebugStr for Name:
    fn to_debug_str(self) Str:
        let segments = " ".join(
            self.segments.iter().map<Str>(fn(it NameSegment) Str => it.to_debug_str())
        )
        f"(@name {segments}{self.meta.to_debug_str()})"
    end
end

impl ToDebugStr for Type:
    fn to_debug_str(self) Str:
        match self.kind:
            TypeKind.Name(x) => x.to_debug_str()
            TypeKind.Unit => "(@unit)"
        end
    end
end

impl ToDebugStr for Param:
    fn to_debug_str(self) Str => f"(@param {self.ident.to_debug_str()}{self.meta.to_debug_str()} {self.type.to_debug_str()})"
end

impl ToDebugStr for FnDecl:
    fn to_debug_str(self) Str:
        let params = " ".join(
            self.params.iter().map<Str>(fn(it Param) Str => it.to_debug_str())
        )
        let return_type = self.return_type.to_debug_str()
        f"(@fndecl {self.ident.to_debug_str()}{self.meta.to_debug_str()}{" ".when(params.len() > 0)}{params} {return_type})"
    end
end

impl ToDebugStr for ModuleItem:
    fn to_debug_str(self) Str:
        match self:
            ModuleItem.Fn(x) => x.to_debug_str()
        end
    end
end

impl ToDebugStr for Module:
    fn to_debug_str(self) Str:
        let items = " ".join(
            self.items.iter().map<Str>(fn(it ModuleItem) Str => it.to_debug_str())
        )
        f"(@mod{" ".when(items.len() > 0)}{items})"
    end
end

impl ToDebugStr for BlockItem:
    fn to_debug_str(self) Str:
        match self:
            BlockItem.Expr(x) => x.to_debug_str()
            BlockItem.Fn(x) => x.to_debug_str()
        end
    end
end

impl ToDebugStr for Fn:
    fn to_debug_str(self) Str:
        let body = self.body.to_debug_str()
        let decl = self.decl.to_debug_str()
        f"(@fn {decl} {body})"
    end
end

impl ToDebugStr for Block:
    fn to_debug_str(self) Str:
        if self.items.len() == 0 => return "(@block)"
        let body = " ".join(
            self.items.iter().map<Str>(fn(it BlockItem) Str => it.to_debug_str())
        )
        f"(@block {body})"
    end
end

impl ToDebugStr for ParseErrorKind:
    fn to_debug_str(self) Str:
        match self:
            ExprExpected(token) => f"(@error expr expected at {token.span})"
            IdentExpected(token) => f"(@error ident expected at {token.span})"
            InvalidIntLiteral(token) => f"(@error invalid int literal at {token.span})"
            UnexpectedEOF => "(@error eof)"
            UnexpectedToken(token) => f"(@error unexpected token `{token}` at {token.span})"
        end
    end
end

impl ToDebugStr for Literal:
    fn to_debug_str(self) Str:
        let lit = match self.kind:
            LiteralKind.BoolLiteral(value) => f"(@bool {value})"
            LiteralKind.IntLiteral(value) => f"(@int {value})"
            LiteralKind.StrLiteral(value) => f"(@str{" ".when(value.len() > 0)}{value.replace("\n", "\\n")})"
            LiteralKind.UnitLiteral=> "(@unit)"
        end
        f"{lit}{self.meta.to_debug_str()}"
    end
end

impl ToDebugStr for Call:
    fn to_debug_str(self) Str:
        let args = " ".join(
            self.args.iter().map<Str>(fn(it Expr) Str => it.to_debug_str())
        )
        f"(@call {self.target.to_debug_str()}{" ".when(args.len() > 0)}{args}{self.meta.to_debug_str()})"
    end
end

impl ToDebugStr for Ident:
    fn to_debug_str(self) Str => f"(@ident {self.name}{self.meta.to_debug_str()})"
end

impl ToDebugStr for FStr:
    fn to_debug_str(self) Str:
        let exprs = " ".join(
            self.exprs.iter().map<Str>(fn(it Expr) Str => it.to_debug_str())
        )
        f"(@fstr{" ".when(exprs.len() > 0)}{exprs}{self.meta.to_debug_str()})"
    end
end

impl ToDebugStr for BinaryExpr:
    fn to_debug_str(self) Str:
        let kind = match self.kind:
            BinaryExprKind.Add => "+"
            BinaryExprKind.And => "and"
            BinaryExprKind.Div => "/"
            BinaryExprKind.Equal => "=="
            BinaryExprKind.GreaterThan => ">"
            BinaryExprKind.GreaterThanOrEqual => ">="
            BinaryExprKind.LessThan => "<"
            BinaryExprKind.LessThanOrEqual => "<="
            BinaryExprKind.Mul => "*"
            BinaryExprKind.NotEqual => "!="
            BinaryExprKind.Or => "or"
            BinaryExprKind.Sub => "-"
        end
        f"(@binexpr {kind} {self.lhs.to_debug_str()} {self.rhs.to_debug_str()})"
    end
end

impl ToDebugStr for Assignment:
    fn to_debug_str(self) Str => f"(@assign {self.lhs.to_debug_str()} {self.rhs.to_debug_str()})"
end

impl ToDebugStr for Expr:
    fn to_debug_str(self) Str:
        match self:
            Expr.Assignment(value) => value.to_debug_str()
            Expr.BinaryExpr(value) => value.to_debug_str()
            Expr.Call(value) => value.to_debug_str()
            Expr.FStr(value) => value.to_debug_str()
            Expr.Ident(value) => value.to_debug_str()
            Expr.Literal(value) => value.to_debug_str()
        end
    end
end

impl ToDebugStr for ParseError:
    fn to_debug_str(self) Str => self.kind.to_debug_str()
end

impl ToStr for ParseError:
    fn to_str(self) Str => self.to_debug_str()
end
