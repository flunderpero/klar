use .lexer.Span
use .lexer.Token

trait ToDebugStr:
    --- Convert the item to a string representation that does retain
        all information, but is easier to test / reason about.
    ---
    fn to_debug_str(self) Str

    fn to_debug_str_multiline(self) Str:
        --- Same as `to_debug_str`, but with newlines and indentation.
        ---
        let str = self.to_debug_str()
        mut res = ""
        mut indent = 0
        mut iter = str.iter()
        loop:
            match iter.next():
                Some('('):
                    if res.len() > 0:
                        res.push("\n")
                    end
                    res.push("  ".repeat(indent))
                    res.push("(")
                    indent = indent + 1
                end
                Some(')'):
                    indent = indent - 1
                    res.push(")")
                end
                Some(x) => res.push_char(x)
                None => break
            end
        end
        res
    end
end

enum ParseErrorKind:
    ExprExpected(Token)
    IdentExpected(Token)
    InvalidIntLiteral(Token)
    ParamExpected(Token)
    TypeExpected(Token)
    UnexpectedEOF
    UnexpectedFnDecl(FnDecl)
    UnexpectedToken(Token)
end

struct ParseError:
    kind ParseErrorKind
    meta Meta
end

enum LiteralKind:
    IntLiteral(Int)
    BoolLiteral(Bool)
    StrLiteral(Str)
    UnitLiteral
end

struct Literal:
    kind LiteralKind
    meta Meta
end

struct Call:
    target Expr
    args Vector<Expr>
    meta Meta
end

struct Ident:
    name Str
    meta Meta
end

struct FStr:
    exprs Vector<Expr>
    meta Meta
end

enum BinaryExprKind:
    Add
    And
    Div
    Equal
    GreaterThan
    GreaterThanOrEqual
    LessThan
    LessThanOrEqual
    Mul
    NotEqual
    Or
    Sub
end

struct BinaryExpr:
    lhs Expr
    rhs Expr
    kind BinaryExprKind
    meta Meta
end

enum UnaryExprKind:
    Neg
    Not
end

struct UnaryExpr:
    expr Expr
    kind UnaryExprKind
    meta Meta
end

struct Assignment:
    lhs Expr
    rhs Expr
    meta Meta
end

struct Let:
    ident Ident
    is_mut Bool
    type_ Type
    expr Expr
    meta Meta
end

struct If:
    cond Expr
    then_block Block
    else_block Block?
    meta Meta
end

struct Loop:
    body Block
    meta Meta
end

struct Break:
    meta Meta
end

struct Continue:
    meta Meta
end

enum Expr:
    Assignment(Assignment)
    BinaryExpr(BinaryExpr)
    Call(Call)
    FStr(FStr)
    Ident(Ident)
    If(If)
    Let(Let)
    Literal(Literal)
    UnaryExpr(UnaryExpr)
    Loop(Loop)
    Break(Break)
    Continue(Continue)
end

struct GenericArg:
    type_ Type
    meta Meta
end

struct Name:
    ident Ident
    args Vector<GenericArg>?
    meta Meta
end

struct FQN:
    --- A fully qualified name is a series of names, separated by `.`.
        A name can have generic arguments.
        Example: `module.Enum<T>.Variant`.
    ---
    names Vector<Name>
    meta Meta
end

enum TypeKind:
    FQN(FQN)
    Infer
    Self
    Unit
end

struct Type:
    kind TypeKind
    meta Meta
end

struct Param:
    ident Ident
    type_ Type
    meta Meta
end

struct FnDecl:
    ident Ident
    params Vector<Param>
    return_type Type
    meta Meta
end

struct Fn:
    decl FnDecl
    body Block
    meta Meta
end

struct Block:
    items Vector<BlockItem>
    meta Meta
end

struct Trait:
    name Name
    fn_decls Vector<FnDecl>
    fn_impls Vector<Fn>
    meta Meta
end

enum EnumVariantKind:
    Tuple(Vector<Type>)
    Unit
end

struct EnumVariant:
    ident Ident
    kind EnumVariantKind
    meta Meta
end

struct Enum:
    name Name
    variants Vector<EnumVariant>
    meta Meta
end

struct Struct:
    name Name
    fields Vector<Field>
    meta Meta
end

struct Field:
    ident Ident
    type_ Type
    meta Meta
end

struct Impl:
    -- todo (lang feat): Make `type` a reserved word for future use.
    type_ FQN
    trait_ FQN?
    fn_impls Vector<Fn>
    meta Meta
end

enum BlockItem:
    Struct(Struct)
    Enum(Enum)
    Expr(Expr)
    Fn(Fn)
    Impl(Impl)
    Trait(Trait)
end

enum ModuleItem:
    -- Extern(Extern)
    -- Use(Use)
    Struct(Struct)
    Enum(Enum)
    Fn(Fn)
    Impl(Impl)
    Trait(Trait)
end

struct Module:
    items Vector<ModuleItem>
    meta Meta
end

struct Id:
    --- Each item in the AST is assigned a unique ID. 
    ---
    -- todo (lang-feat): This should be private.
    id Int
end

struct Meta:
    id Id
    --- The tokens taken from the source code. These tokens never
        change even if the item is desugared.
    ---
    tokens Vector<Token>
end

impl Meta:
    fn new(tokens Vector<Token>) Meta:
        assert(tokens.len() > 0)
        let id = Id{id: int_next()} 
        Meta{id: id, tokens}
    end

    fn span(self) Span:
        let last = self.tokens.len() - 1
        -- todo (lang-feat): We should be able to just use `-1` as the end index.
        self.tokens[0].span.combine(self.tokens[last].span)
    end
end

impl ToDebugStr for Meta:
    fn to_debug_str(self) Str:
        f"(@meta {self.id.id} {self.span()})"
    end
end

impl ToDebugStr for Name:
    fn to_debug_str(self) Str:
        let args = match self.args:
            Some(x) => " ".join(
                x.iter().map<Str>(fn(it GenericArg) Str => it.type_.to_debug_str())
            )
            None => ""
        end
        f"(@name {self.ident.to_debug_str()}{" ".when(args.len() > 0)}{args})"
    end
end

impl ToDebugStr for FQN:
    fn to_debug_str(self) Str:
        let names = " ".join(
            self.names.iter().map<Str>(fn(it Name) Str => it.to_debug_str())
        )
        f"(@fqn {names})"
    end
end

impl ToDebugStr for Type:
    fn to_debug_str(self) Str:
        match self.kind:
            TypeKind.FQN(x) => f"(@type {x.to_debug_str()})"
            TypeKind.Unit => "(@type (@unit))"
            TypeKind.Self => "(@type (@self))"
            TypeKind.Infer => "(@type (@infer))"
        end
    end
end

impl ToDebugStr for Param:
    fn to_debug_str(self) Str => f"(@param {self.ident.to_debug_str()} {self.type_.to_debug_str()})"
end

impl ToDebugStr for FnDecl:
    fn to_debug_str(self) Str:
        let params = " ".join(
            self.params.iter().map<Str>(fn(it Param) Str => it.to_debug_str())
        )
        let return_type = self.return_type.to_debug_str()
        f"(@fndecl {self.ident.to_debug_str()}{" ".when(params.len() > 0)}{params} {return_type})"
    end
end

impl ToDebugStr for Trait:
    fn to_debug_str(self) Str:
        let fn_decls = " ".join(
            self.fn_decls.iter().map<Str>(fn(it FnDecl) Str => it.to_debug_str())
        )
        let fn_impls = " ".join(
            self.fn_impls.iter().map<Str>(fn(it Fn) Str => it.to_debug_str())
        )
        f"(@trait {self.name.to_debug_str()}{" ".when(fn_decls.len() > 0)}{fn_decls}{" ".when(fn_impls.len() > 0)}{fn_impls})"
    end
end

impl ToDebugStr for EnumVariantKind:
    fn to_debug_str(self) Str:
        match self:
            EnumVariantKind.Tuple(x):
                let types = " ".join(
                    x.iter().map<Str>(fn(it Type) Str => it.to_debug_str())
                )
                f"(@tuple {types})"
            end
            EnumVariantKind.Unit => "(@unit)"
        end
    end
end

impl ToDebugStr for EnumVariant:
    fn to_debug_str(self) Str:
        let kind = self.kind.to_debug_str()
        f"(@variant {self.ident.to_debug_str()} {kind})"
    end
end

impl ToDebugStr for Enum:
    fn to_debug_str(self) Str:
        let variants = " ".join(
            self.variants.iter().map<Str>(fn(it EnumVariant) Str => it.to_debug_str())
        )
        f"(@enum {self.name.to_debug_str()}{" ".when(variants.len() > 0)}{variants})"
    end
end

impl ToDebugStr for Field:
    fn to_debug_str(self) Str => f"(@field {self.ident.to_debug_str()} {self.type_.to_debug_str()})"
end

impl ToDebugStr for Struct:
    fn to_debug_str(self) Str:
        let fields = " ".join(
            self.fields.iter().map<Str>(fn(it Field) Str => it.to_debug_str())
        )
        f"(@struct {self.name.to_debug_str()}{" ".when(fields.len() > 0)}{fields})"
    end
end

impl ToDebugStr for Impl:
    fn to_debug_str(self) Str:
        let trait_ = match self.trait_:
            Some(x) => f"{x.to_debug_str()} "
            None => ""
        end
        let fn_impls = " ".join(
            self.fn_impls.iter().map<Str>(fn(it Fn) Str => it.to_debug_str())
        )
        f"(@impl {trait_}{self.type_.to_debug_str()}{" ".when(fn_impls.len() > 0)}{fn_impls})"
    end
end

impl ToDebugStr for ModuleItem:
    fn to_debug_str(self) Str:
        match self:
            ModuleItem.Enum(x) => x.to_debug_str()
            ModuleItem.Fn(x) => x.to_debug_str()
            ModuleItem.Impl(x) => x.to_debug_str()
            ModuleItem.Trait(x) => x.to_debug_str()
            ModuleItem.Struct(x) => x.to_debug_str()
        end
    end
end

impl ToDebugStr for Module:
    fn to_debug_str(self) Str:
        let items = " ".join(
            self.items.iter().map<Str>(fn(it ModuleItem) Str => it.to_debug_str())
        )
        f"(@mod{" ".when(items.len() > 0)}{items})"
    end
end

impl ToDebugStr for BlockItem:
    fn to_debug_str(self) Str:
        match self:
            BlockItem.Enum(x) => x.to_debug_str()
            BlockItem.Expr(x) => x.to_debug_str()
            BlockItem.Fn(x) => x.to_debug_str()
            BlockItem.Impl(x) => x.to_debug_str()
            BlockItem.Trait(x) => x.to_debug_str()
            BlockItem.Struct(x) => x.to_debug_str()
        end
    end
end

impl ToDebugStr for Fn:
    fn to_debug_str(self) Str:
        let body = self.body.to_debug_str()
        let decl = self.decl.to_debug_str()
        f"(@fn {decl} {body})"
    end
end

impl ToDebugStr for Block:
    fn to_debug_str(self) Str:
        if self.items.len() == 0 => return "(@block)"
        let body = " ".join(
            self.items.iter().map<Str>(fn(it BlockItem) Str => it.to_debug_str())
        )
        f"(@block {body})"
    end
end

impl ToDebugStr for ParseErrorKind:
    fn to_debug_str(self) Str:
        match self:
            ParseErrorKind.ExprExpected(token) => f"(@error expr expected at {token.span})"
            ParseErrorKind.IdentExpected(token) => f"(@error ident expected at {token.span})"
            ParseErrorKind.InvalidIntLiteral(token) => f"(@error invalid int literal at {token.span})"
            ParseErrorKind.ParamExpected(token) => f"(@error param expected at {token.span})"
            ParseErrorKind.TypeExpected(token) => f"(@error type expected at {token.span})"
            ParseErrorKind.UnexpectedEOF => "(@error eof)"
            ParseErrorKind.UnexpectedFnDecl(decl) => f"(@error unexpected fn decl `{decl.ident}` at {decl.meta.span()})"
            ParseErrorKind.UnexpectedToken(token) => f"(@error unexpected token `{token}` at {token.span})"
        end
    end
end

impl ToDebugStr for Literal:
    fn to_debug_str(self) Str:
        let lit = match self.kind:
            LiteralKind.BoolLiteral(value) => f"(@bool {value})"
            LiteralKind.IntLiteral(value) => f"(@int {value})"
            LiteralKind.StrLiteral(value) => f"(@str{" ".when(value.len() > 0)}{value.replace("\n", "\\n")})"
            LiteralKind.UnitLiteral=> "(@unit)"
        end
        f"{lit}"
    end
end

impl ToDebugStr for Call:
    fn to_debug_str(self) Str:
        let args = " ".join(
            self.args.iter().map<Str>(fn(it Expr) Str => it.to_debug_str())
        )
        f"(@call {self.target.to_debug_str()}{" ".when(args.len() > 0)}{args})"
    end
end

impl ToDebugStr for Ident:
    fn to_debug_str(self) Str => f"(@ident {self.name})"
end

impl ToStr for Ident:
    fn to_str(self) Str => self.name
end

impl ToDebugStr for FStr:
    fn to_debug_str(self) Str:
        let exprs = " ".join(
            self.exprs.iter().map<Str>(fn(it Expr) Str => it.to_debug_str())
        )
        f"(@fstr{" ".when(exprs.len() > 0)}{exprs})"
    end
end

impl ToDebugStr for BinaryExpr:
    fn to_debug_str(self) Str:
        let kind = match self.kind:
            BinaryExprKind.Add => "+"
            BinaryExprKind.And => "and"
            BinaryExprKind.Div => "/"
            BinaryExprKind.Equal => "=="
            BinaryExprKind.GreaterThan => ">"
            BinaryExprKind.GreaterThanOrEqual => ">="
            BinaryExprKind.LessThan => "<"
            BinaryExprKind.LessThanOrEqual => "<="
            BinaryExprKind.Mul => "*"
            BinaryExprKind.NotEqual => "!="
            BinaryExprKind.Or => "or"
            BinaryExprKind.Sub => "-"
        end
        f"(@binexpr {kind} {self.lhs.to_debug_str()} {self.rhs.to_debug_str()})"
    end
end

impl ToDebugStr for Assignment:
    fn to_debug_str(self) Str => f"(@assign {self.lhs.to_debug_str()} {self.rhs.to_debug_str()})"
end

impl ToDebugStr for Let:
    fn to_debug_str(self) Str:
        let name = if self.is_mut => "mut" else => "let"
        f"(@{name} {self.ident.to_debug_str()} {self.type_.to_debug_str()} {self.expr.to_debug_str()})"
    end
end

impl ToDebugStr for If:
    fn to_debug_str(self) Str:
        let else_block = match self.else_block:
            Some(x) => f" {x.to_debug_str()}"
            None => ""
        end
        f"(@if {self.cond.to_debug_str()} {self.then_block.to_debug_str()}{else_block})"
    end
end

impl ToDebugStr for UnaryExpr:
    fn to_debug_str(self) Str:
        let kind = match self.kind:
            UnaryExprKind.Neg => "-"
            UnaryExprKind.Not => "not"
        end
        f"(@unexpr {kind} {self.expr.to_debug_str()})"
    end
end

impl ToDebugStr for Loop:
    fn to_debug_str(self) Str => f"(@loop {self.body.to_debug_str()})"
end

impl ToDebugStr for Break:
    fn to_debug_str(self) Str => "(@break)"
end

impl ToDebugStr for Continue:
    fn to_debug_str(self) Str => "(@continue)"
end

impl ToDebugStr for Expr:
    fn to_debug_str(self) Str:
        match self:
            Expr.Assignment(value) => value.to_debug_str()
            Expr.BinaryExpr(value) => value.to_debug_str()
            Expr.Break(value) => value.to_debug_str()
            Expr.Call(value) => value.to_debug_str()
            Expr.Continue(value) => value.to_debug_str()
            Expr.FStr(value) => value.to_debug_str()
            Expr.Ident(value) => value.to_debug_str()
            Expr.If(value) => value.to_debug_str()
            Expr.Let(value) => value.to_debug_str()
            Expr.Literal(value) => value.to_debug_str()
            Expr.Loop(value) => value.to_debug_str()
            Expr.UnaryExpr(value) => value.to_debug_str()
        end
    end
end

impl ToDebugStr for ParseError:
    fn to_debug_str(self) Str => self.kind.to_debug_str()
end

impl ToStr for ParseError:
    fn to_str(self) Str => self.to_debug_str()
end
