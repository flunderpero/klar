--- = Parser 
    The parse parses a stream of tokens into a high level AST.

    == Desugaring

    Some of the syntactic sugar in the language will be converted
    to their canonical form by the parser:

    - `throws` will convert the return type to `Result<T, Error>`
      as well as converting the return expression (both explicit and implicit)
      to `Ok(expr)`.
    - `<type>?` will convert to `Option<type>` as well as converting
      the return expression (both explicit and implicit) to `Some(expr)`.
      All optional call arguments will be converted to `Some(expr)` as well.

    `Item.is_synthetic` is used to indicate whether the item
    has been altered by the parser as part of desugaring.

    == TODO: Ambiguity

    These constructs are still ambiguous:
---

use .ast.Assignment
use .ast.BinaryExpr
use .ast.BinaryExprKind
use .ast.Block
use .ast.BlockItem
use .ast.Break
use .ast.Call
use .ast.Continue
use .ast.Enum
use .ast.EnumVariant
use .ast.EnumVariantKind
use .ast.Expr
use .ast.FQN
use .ast.FStr
use .ast.Field
use .ast.Fn
use .ast.FnDecl
use .ast.GenericArg
use .ast.Ident
use .ast.If
use .ast.Impl
use .ast.Let
use .ast.Literal
use .ast.LiteralKind
use .ast.Loop
use .ast.Meta
use .ast.Module
use .ast.ModuleItem
use .ast.Name
use .ast.Param
use .ast.ParseError
use .ast.ParseErrorKind
use .ast.Return
use .ast.Struct
use .ast.ToDebugStr
use .ast.Trait
use .ast.Type
use .ast.TypeKind
use .ast.UnaryExpr
use .ast.UnaryExprKind
use .lexer.FStrItem
use .lexer.Token
use .lexer.TokenKind
use ParseErrorKind.*

struct TokenIter:
    --- An iterator over tokens that can be peeked and rewound.
    ---
    tokens Vector<Token>
    peeked Token?
    idx Int
end

impl Iterator<Token> for TokenIter:
    fn next(mut self) Token?:
        --- Return the next token or `None` ignoring whitespace and comments.
        ---
        loop:
            let token = self.immediate()
            match token:
                Some(
                    Token{kind: TokenKind.WhiteSpace(_) | TokenKind.Comment(_), span: _}
                ) => continue
                _ => return token
            end
        end
        -- todo (lang-feat): Semantic analysis should be able to infer that this is unreachable.
        None
    end

    fn immediate(mut self) Token?:
        --- Return the next token or `None` but including whitespace and comments.
        ---
        if self.idx >= self.tokens.len() => return None
        let v = if self.peeked.is_some():
            let value = self.peeked.unwrap()
            self.peeked = None
            value
        else:
            let value = self.tokens[self.idx]
            value
        end
        self.idx = self.idx + 1
        v
    end

    fn peek(mut self) Token?:
        --- Peek the next token (ignoring whitespace and comments).
        ---
        loop:
            let token = self.peek_immediate()
            match token:
                Some(
                    Token{kind: TokenKind.WhiteSpace(_) | TokenKind.Comment(_), span: _}
                ) => self.immediate()
                _ => return token
            end
        end
        None
    end

    fn peek_immediate(mut self) Token?:
        --- Peek the next token (including whitespace and comments).
        ---
        if self.peeked.is_some() => return self.peeked
        if self.idx >= self.tokens.len() => return None
        let value = self.tokens[self.idx]
        self.peeked = Some(value)
        value
    end

    fn force_next(mut self) Token throws ParseError:
        --- Return the next token (excluding whitespace and commetns) or 
            an error if there are no more tokens.
        ---
        match self.next():
            Some<Token>(token) => Ok(token)
            None => return parse_error(UnexpectedEOF, None)
        end
    end

    fn force_immediate(mut self) Token throws ParseError:
        --- Return the next token (including whitespace and comments) or 
            an error if there are no more tokens.
        ---
        match self.immediate():
            Some<Token>(token) => Ok(token)
            None => return parse_error(UnexpectedEOF, None)
        end
    end

    fn mark(self) Int => self.idx 

    fn mark_prev(self) Int => self.idx - 1

    fn reset(mut self, mark Int):
        self.peeked = None
        self.idx = mark
    end

    fn tokens_since(mut self, mark Int) Vector<Token>:
        --- Returns all tokens since the given mark (inclusive).
        ---
        if mark >= self.idx or mark < 0 => return Vector<Token>.new()
        self.tokens.slice_copy(mark, self.idx)
    end

    fn expect_ident(mut self) Str throws ParseError:
        --- Expect the next token (without whitespace and comments) to be an identifier.
        ---
        match self.force_next()!:
            Token{kind: TokenKind.Ident(name), span: _ } => Ok(name)
            token => return parse_error(UnexpectedToken(token), token)
        end
    end

    fn expect_token(mut self, predicate (fn(Token) Bool)) Token throws ParseError:
        --- Expect the next token (without whitespace and comments) to match the given predicate.
        ---
        let token = self.force_next()!
        if not predicate(token) => return parse_error(UnexpectedToken(token), token)
        token
    end

    fn expect_lexical_token(mut self, kind TokenKind) Token throws ParseError:
        --- Expect the next token (without whitespace and comments) to match the given kind.
        ---
        self.expect_token(fn(token Token) Bool => token.kind == kind)!
    end

    fn expect_immediate_token(mut self, predicate (fn(Token) Bool)) Token throws ParseError:
        --- Expect the next token (including whitespace and comments) to match the given predicate.
        ---
        let token = self.force_immediate()!
        if not predicate(token) => return parse_error(UnexpectedToken(token), token)
        token
    end

    fn expect_immediate_lexical_token(mut self, kind TokenKind) Token throws ParseError:
        --- Expect the next token (including whitespace and comments) to match the given kind.
        ---
        self.expect_immediate_token(fn(token Token) Bool => token.kind == kind)!
    end
end

impl TokenIter:
    fn new(tokens Vector<Token>) TokenIter:
        TokenIter{tokens, peeked: None, idx: 0}
    end
end

struct Parser:
    iter TokenIter
end

impl Parser:

    fn new(iter TokenIter) Parser:
        Parser{iter}
    end

    fn parse_module(mut self) Module throws ParseError:
        -- The main entry point to parse a Klar module.
        let mark = self.iter.mark()
        let items = Vector<ModuleItem>.new()
        loop:
            let token_option = self.iter.next()
            if token_option.is_none() => break
            let token = token_option.unwrap()
            let item_option = self.parse_item(token)!
            if item_option.is_none() => return parse_error(UnexpectedToken(token), token) 
            let item = item_option.unwrap()
            items.push(
                match item:
                    ParseItem.Fn(f) => ModuleItem.Fn(f)
                    ParseItem.Trait(t) => ModuleItem.Trait(t)
                    ParseItem.Struct(t) => ModuleItem.Struct(t)
                    ParseItem.Impl(i) => ModuleItem.Impl(i)
                    ParseItem.Enum(e) => ModuleItem.Enum(e)
                    ParseItem.FnDecl(f) => return parse_error(UnexpectedFnDecl(f), token)
                end
            )
        end
        Module{items, meta: self.meta(mark)}
    end

    fn parse_item(mut self, token Token) ParseItem? throws ParseError:
        match token.kind:
            TokenKind.Fn: 
                let decl = self.parse_fn_decl(token)!
                match self.iter.peek():
                    Some(Token{kind: TokenKind.FatArrow | TokenKind.Colon, span: _}) =>
                        ParseItem.Fn(self.parse_fn_def(decl)!)
                    _ => ParseItem.FnDecl(decl)
                end
            end
            TokenKind.Trait => ParseItem.Trait(self.parse_trait()!)
            TokenKind.Enum => ParseItem.Enum(self.parse_enum()!)
            TokenKind.Struct => ParseItem.Struct(self.parse_struct()!)
            TokenKind.Impl => ParseItem.Impl(self.parse_impl()!)
            _ => return None
        end
    end

    fn parse_expr(mut self, token Token) Expr? throws ParseError:
        self.parse_binary_expr(token, 1)!
    end

    fn parse_binary_expr(mut self, token Token, min_prec Int) Expr? throws ParseError:
        --- Parse a binary expression with precedence `min_prec` or higher.
            Each binary operator has a precedence. The higher the precedence
            the tighter the binding. For example, `1 + 2 * 3` is parsed as
            `1 + (2 * 3)` because `*` has a higher precedence than `+`.

            If the operator is the assignment operator `=` then it will
            be parsed as an assignment expression. The precedence of the
            assignment is the lowest possible precedence.
        ---
        let mark = self.iter.mark_prev()
        let expr = self.parse_primary_expr(token)!
        if expr.is_none() => return None
        mut lhs = expr.unwrap()
        loop:
            let op_token = self.iter.peek()
            if op_token.is_none() => break
            let kind_and_prec = match op_token.unwrap().kind:
                None => break
                TokenKind.Equal => return self.parse_assignment(lhs, mark)!
                TokenKind.Or => (BinaryExprKind.Or, 1)
                TokenKind.And => (BinaryExprKind.And, 2)
                TokenKind.DoubleEqual => (BinaryExprKind.Equal, 3)
                TokenKind.NotEqual => (BinaryExprKind.NotEqual, 3)
                TokenKind.LessThan => (BinaryExprKind.LessThan, 4)
                TokenKind.LessThanOrEqual => (BinaryExprKind.LessThanOrEqual, 4)
                TokenKind.GreaterThan => (BinaryExprKind.GreaterThan, 4)
                TokenKind.GreaterThanOrEqual => (BinaryExprKind.GreaterThanOrEqual, 4)
                TokenKind.Plus => (BinaryExprKind.Add, 5)
                TokenKind.Minus => (BinaryExprKind.Sub, 5)
                TokenKind.Star => (BinaryExprKind.Mul, 6)
                TokenKind.Slash => (BinaryExprKind.Div, 6)
                _ => break
            end
            -- todo (lang-feat): We should be able to destruct the tuple.
            let kind = kind_and_prec.0
            let prec = kind_and_prec.1
            if prec < min_prec => break
            self.iter.next()
            let rhs_token = self.iter.force_next()!
            let rhs = self.parse_binary_expr(rhs_token, prec + 1)!
            if rhs.is_none() => return parse_error(ExprExpected(rhs_token), rhs_token)
            lhs = Expr.BinaryExpr(BinaryExpr{kind, lhs, rhs: rhs.unwrap(), meta: self.meta(mark)})
        end
        lhs
    end

    fn parse_primary_expr(mut self, token Token) Expr? throws ParseError:
        let mark = self.iter.mark_prev()
        mut expr = match token.kind:
            TokenKind.IntLiteral(i) => Expr.Literal(self.parse_int_literal(i, token)!)
            TokenKind.BoolLiteral(b) => 
                Expr.Literal(Literal{kind: LiteralKind.BoolLiteral(b), meta: self.meta(mark)})
            TokenKind.StrLiteral(s, _) => 
                Expr.Literal(Literal{kind: LiteralKind.StrLiteral(s), meta: self.meta(mark)})
            TokenKind.LParen => self.parse_unit_or_tuple_literal_or_parentheses(token)!
            TokenKind.Ident(name) => Expr.Ident(self.parse_ident(token)!)
            TokenKind.If => Expr.If(self.parse_if(token)!)
            TokenKind.FStr(items, _) => Expr.FStr(self.parse_fstr(items)!)
            TokenKind.Let => Expr.Let(self.parse_let_or_mut(token)!)
            TokenKind.Mut => Expr.Let(self.parse_let_or_mut(token)!)
            TokenKind.Break => Expr.Break(Break{meta: self.meta(mark)})
            TokenKind.Continue => Expr.Continue(Continue{meta: self.meta(mark)})
            TokenKind.Loop => Expr.Loop(self.parse_loop(token)!)
            TokenKind.Return => Expr.Return(self.parse_return()!)
            _:
                let unary_expr = self.parse_unary_expr(token)!
                match unary_expr:
                    Some<UnaryExpr>(x) => Expr.UnaryExpr(x)
                    None => return None
                end
            end
        end
        loop:
            expr = match self.iter.peek_immediate():
                Some(Token{kind: TokenKind.LParen, span: _}) => 
                    Expr.Call(self.parse_call(expr)!)
                _ => break
            end
        end
        expr
    end

    fn parse_unary_expr(mut self, token Token) UnaryExpr? throws ParseError:
        let mark = self.iter.mark_prev()
        let kind = match token.kind:
            TokenKind.Minus => UnaryExprKind.Neg
            TokenKind.Not => UnaryExprKind.Not
            _ => return None
        end
        let expr_token = self.iter.force_next()!
        let expr = self.parse_primary_expr(expr_token)!
        match expr:
            -- todo: We are not able to reuse the name `expr` here, the stage0 compiler
            --       throws a JS error.
            Some(x) => UnaryExpr{kind, expr: x, meta: self.meta(mark)}
            None => return parse_error(ExprExpected(expr_token), expr_token)
        end
    end

    fn parse_loop(mut self, token Token) Loop throws ParseError:
        let mark = self.iter.mark_prev()
        let body = self.parse_block()!
        Loop{body, meta: self.meta(mark)}
    end

    fn parse_return(mut self) Return throws ParseError:
        let mark = self.iter.mark_prev()
        let expr_token = self.iter.force_next()!
        match self.parse_expr(expr_token)!:
            Some<Expr>(expr) => Return{expr, meta: self.meta(mark)}
            None => return parse_error(ExprExpected(expr_token), expr_token)
        end
    end

    fn parse_ident(mut self, token Token) Ident throws ParseError:
        let mark = self.iter.mark_prev()
        match token.kind:
            TokenKind.Ident(name) => Ident{name, meta: self.meta(mark)}
            _ => return parse_error(IdentExpected(token), token)
        end
    end

    fn parse_generic_args(mut self) Vector<GenericArg>? throws ParseError:
        let args = Vector<GenericArg>.new()
        match self.iter.peek():
            Some(Token{kind: TokenKind.LessThan, span: _}) => ()
            _ => return None
        end
        self.iter.force_next()!
        loop:
            let token = self.iter.force_next()!
            match token.kind:
                TokenKind.Ident(name):
                    let mark = self.iter.mark_prev()
                    let type_ = self.parse_type(token)!
                    args.push(GenericArg{type_, meta: self.meta(mark)})
                    match self.iter.force_next()!:
                        Token{kind: TokenKind.Comma, span: _} => ()
                        Token{kind: TokenKind.GreaterThan, span: _} => break
                        _ => return parse_error(UnexpectedToken(token), token)
                    end
                    self.iter.force_next()!
                end
                _ => return parse_error(UnexpectedToken(token), token)
            end
        end
        args
    end

    fn parse_name(mut self, token Token) Name throws ParseError:
        let mark = self.iter.mark_prev()
        let ident = self.parse_ident(token)!
        let args = self.parse_generic_args()!
        Name{ident, args, meta: self.meta(mark)}
    end

    fn parse_fqn(mut self, token Token) FQN throws ParseError:
        let root_mark = self.iter.mark_prev()
        let names = Vector<Name>.new()
        -- The first part of the name must be an identifier.
        match token.kind:
            TokenKind.Ident(_) => names.push(self.parse_name(token)!)
            _ => return parse_error(IdentExpected(token), token)
        end
        -- todo: parse more segments.
        FQN{names, meta: self.meta(root_mark)}
    end

    fn parse_type(mut self, token Token) Type throws ParseError:
        let mark = self.iter.mark_prev()
        let kind = match token.kind:
            TokenKind.Ident(name) => TypeKind.FQN(self.parse_fqn(token)!)
            _ => return parse_error(UnexpectedToken(token), token)
        end
        Type{kind, meta: self.meta(mark)}
    end

    fn try_parse_type(mut self) Type? throws ParseError:
        let mark = self.iter.mark()
        match self.iter.peek():
            Some(Token{kind: TokenKind.Ident(_), span: _}) => Some(self.parse_type(self.iter.force_next()!)!)
            _ => None
        end
    end

    fn parse_let_or_mut(mut self, token Token) Let throws ParseError:
        --- Parse a `let` or `mut` declaration depending on the given token.
        ---
        let mark = self.iter.mark_prev()
        let is_mut = token.kind == TokenKind.Mut
        let ident = self.parse_ident(self.iter.force_next()!)!
        let type_ = match self.try_parse_type()!:
            Some(t) => t
            None => Type{kind: TypeKind.Infer, meta: self.meta_from_token(ident.meta.tokens[0])}
        end
        self.iter.expect_lexical_token(TokenKind.Equal)!
        let expr_token = self.iter.force_next()!
        match self.parse_expr(expr_token)!:
            Some<Expr>(expr) => 
                Let{ident, is_mut, type_, expr, meta: self.meta(mark)}
            None => return parse_error(ExprExpected(expr_token), expr_token)
        end
    end

    fn parse_if(mut self, token Token) If throws ParseError:
        let mark = self.iter.mark_prev()
        let cond_token = self.iter.force_next()!
        let cond = match self.parse_expr(cond_token)!:
            Some(expr) => expr
            None => return parse_error(ExprExpected(cond_token), cond_token)
        end
        let then_block = self.parse_block_advanced(true)!
        let else_block Block? = 
            if then_block.1:
                Some(self.parse_block()!)
            else:
                -- todo: The assignment to `block` should not be needed here. The stage0 type-checker
                --       cannot infer the type of the match expression.
                let block = match self.iter.peek():
                    Some(Token{kind: TokenKind.Else, span: _}):
                        self.iter.force_next()!
                        Some(self.parse_block()!)
                    end
                    _ => None
                end
                block
            end
        If{cond, then_block: then_block.0, else_block, meta: self.meta(mark)}
    end

    fn parse_int_literal(self, value Str, token Token) Literal throws ParseError:
        let mark = self.iter.mark_prev()
        match Int.from_str(value, 10):
            Ok<Int>(i) => Literal{kind: LiteralKind.IntLiteral(i), meta: self.meta(mark)}
            -- todo: The `return` should not be needed here. The stage0 type-checker
            --       cannot infer that the result of the match is the return value 
            --       of the function.
            Error(_) => return parse_error(InvalidIntLiteral(token), token)
        end
    end

    fn parse_unit_or_tuple_literal_or_parentheses(mut self, token Token) Expr throws ParseError:
        let mark = self.iter.mark_prev()
        let immediate = self.iter.peek_immediate()
        if immediate.is_some() and immediate.unwrap().kind == TokenKind.RParen => 
            return Expr.Literal(Literal{kind: LiteralKind.UnitLiteral, meta: self.meta(mark)})
        let exprs = self.parse_comma_separated_exprs()!
        if exprs.len() == 1 => return exprs[0]
        return parse_error(UnexpectedToken(immediate.unwrap()), immediate.unwrap())
    end

    fn parse_fstr(mut self, items Vector<FStrItem>) FStr throws ParseError:
        let mark = self.iter.mark_prev()
        mut exprs = Vector<Expr>.new()
        mut idx = 0
        -- todo (lang-feat): We tried to implement this with `items.iter().map()` but
        --                   we were not able to propagate errors from the map closure.
        loop:
            if idx >= items.len() => break
            let item = items[idx]
            idx = idx + 1
            let expr = match item:
                FStrItem.FStrTokensItem(tokens):
                    mut parser = Parser.new(TokenIter.new(tokens))
                    let expr = parser.parse_expr(parser.iter.force_next()!)!
                    match expr:
                        Some<Expr>(value) => value
                        None => return parse_error(ExprExpected(tokens[0]), tokens[0])
                    end
                end
                FStrItem.FStrStrItem(s):
                    Expr.Literal(Literal{kind: LiteralKind.StrLiteral(s), meta: self.meta(mark)})
                end
            end
            exprs.push(expr)
        end
        FStr{exprs, meta: self.meta(mark)}
    end

    fn parse_assignment(mut self, lhs Expr, mark Int) Expr throws ParseError:
        self.iter.expect_lexical_token(TokenKind.Equal)!
        let rhs_token = self.iter.force_next()!
        let rhs = self.parse_expr(rhs_token)!
        if rhs.is_none() => return parse_error(ExprExpected(rhs_token), rhs_token)
        Expr.Assignment(Assignment{ lhs, rhs: rhs.unwrap(), meta: self.meta(mark) })
    end

    fn parse_fn_decl(mut self, token Token) FnDecl throws ParseError:
        let mark = self.iter.mark_prev()
        let ident = self.parse_ident(self.iter.force_next()!)!
        self.iter.expect_lexical_token(TokenKind.LParen)!
        let params = self.parse_params()!
        let return_type = self.try_parse_type()!.unwrap_or(
            Type{kind: TypeKind.Unit, meta: self.meta(mark)}
        )
        FnDecl{ident, params, return_type, meta: self.meta(mark)}
    end

    fn parse_params(mut self) Vector<Param> throws ParseError:
        let params = Vector<Param>.new()
        mut got_comma = false
        loop:
            let next_token = self.iter.force_next()!
            match next_token.kind:
                TokenKind.RParen => break
                TokenKind.Comma:
                    if got_comma => return parse_error(ParamExpected(next_token), next_token)
                    got_comma = true
                    continue
                end
                _: 
                    if params.len() > 0 and not got_comma => 
                        return parse_error(UnexpectedToken(next_token), next_token)
                    got_comma = false
                    params.push(self.parse_param(next_token)!)
                end
            end
        end
        params
    end

    fn parse_param(mut self, token Token) Param throws ParseError:
        let mark = self.iter.mark_prev()
        let ident = self.parse_ident(token)!
        let type_ = if ident.name == "self" => Type{kind: TypeKind.Self, meta: self.meta(mark)}
        else => self.parse_type(self.iter.force_next()!)!
        Param{ident, type_, meta: self.meta(mark)}
    end

    fn parse_fn_def(mut self, decl FnDecl) Fn throws ParseError: 
        let body = self.parse_block()!
        Fn{decl, body, meta: Meta.new(decl.meta.tokens + body.meta.tokens)}
    end

    fn parse_impl(mut self) Impl throws ParseError:
        let mark = self.iter.mark_prev()
        -- todo (lang feat): We should not need to use `mut` here, but should be able
        --                   to express this as a single match expression.
        mut type_ = self.parse_fqn(self.iter.force_next()!)!
        mut trait_ FQN? = None
        match self.iter.peek():
            Some(Token{kind: TokenKind.For, span: _}):
                self.iter.force_next()!;
                -- todo (lang feat): We should not need to use `Some(...)` here.
                trait_ = Some(type_)
                type_ = self.parse_fqn(self.iter.force_next()!)!
            end
            _: 
            end
        end 
        self.iter.expect_lexical_token(TokenKind.Colon)!
        let fn_impls = Vector<Fn>.new()
        loop:
            let next_token = self.iter.force_next()!
            match next_token.kind:
                TokenKind.Fn:
                    let decl = self.parse_fn_decl(next_token)!
                    fn_impls.push(self.parse_fn_def(decl)!)
                end
                TokenKind.End => break
                _ => return parse_error(UnexpectedToken(next_token), next_token)
            end
        end
        return Impl{type_, trait_, fn_impls, meta: self.meta(mark)}
    end

    fn parse_trait(mut self) Trait throws ParseError:
        let mark = self.iter.mark_prev()
        let name = self.parse_name(self.iter.force_next()!)!
        let fn_decls = Vector<FnDecl>.new()
        let fn_impls = Vector<Fn>.new()
        self.iter.expect_lexical_token(TokenKind.Colon)!
        loop:
            let next_token = self.iter.force_next()!
            match next_token.kind:
                TokenKind.Fn:
                    let decl = self.parse_fn_decl(next_token)!
                    match self.iter.peek():
                        Some(Token{kind: TokenKind.FatArrow | TokenKind.Colon, span: _}) =>
                            fn_impls.push(self.parse_fn_def(decl)!)
                        _ => fn_decls.push(decl)
                    end
                end
                TokenKind.End => break
                _ => return parse_error(UnexpectedToken(next_token), next_token)
            end
        end
        Trait{name, fn_decls, fn_impls, meta: self.meta(mark)}
    end

    fn parse_enum(mut self) Enum throws ParseError:
        let mark = self.iter.mark_prev()
        let name = self.parse_name(self.iter.force_next()!)!
        let variants = Vector<EnumVariant>.new()
        self.iter.expect_lexical_token(TokenKind.Colon)!
        loop:
            let next_token = self.iter.force_next()!
            match next_token.kind:
                TokenKind.End => break
                _ => variants.push(self.parse_enum_variant(next_token)!)
            end
        end
        Enum{name, variants, meta: self.meta(mark)}
    end

    fn parse_enum_variant(mut self, token Token) EnumVariant throws ParseError:
        let mark = self.iter.mark_prev()
        let ident = self.parse_ident(token)!
        let kind = match self.iter.peek():
            Some(Token{kind: TokenKind.LParen, span: _}):
                self.iter.force_next()!
                let types = self.parse_comma_separated_types()!
                EnumVariantKind.Tuple(types)
            end
            _ => EnumVariantKind.Unit
        end
        EnumVariant{ident, kind, meta: self.meta(mark)}
    end

    fn parse_struct(mut self) Struct throws ParseError:
        let mark = self.iter.mark_prev()
        let name = self.parse_name(self.iter.force_next()!)!
        let fields = Vector<Field>.new()
        self.iter.expect_lexical_token(TokenKind.Colon)!
        loop:
            let next_token = self.iter.force_next()!
            match next_token.kind:
                TokenKind.End => break
                _ => fields.push(self.parse_field(next_token)!)
            end
        end
        Struct{name, fields, meta: self.meta(mark)}
    end

    fn parse_field(mut self, token Token) Field throws ParseError:
        let mark = self.iter.mark_prev()
        let ident = self.parse_ident(token)!
        let type_ = self.parse_type(self.iter.force_next()!)!
        Field{ident, type_, meta: self.meta(mark)}
    end

    fn parse_comma_separated_types(mut self) Vector<Type> throws ParseError:
        let types = Vector<Type>.new()
        mut got_comma = false
        loop:
            let next_token = self.iter.force_next()!
            match next_token.kind:
                TokenKind.RParen => break
                TokenKind.Comma:
                    if got_comma => return parse_error(TypeExpected(next_token), next_token)
                    got_comma = true
                    continue
                end
                _: 
                    if types.len() > 0 and not got_comma => 
                        return parse_error(UnexpectedToken(next_token), next_token)
                    got_comma = false
                    types.push(self.parse_type(next_token)!)
                end
            end
        end
        types
    end

    fn parse_call(mut self, target Expr) Call throws ParseError:
        let mark = self.iter.mark()
        self.iter.expect_immediate_lexical_token(TokenKind.LParen)!
        let args = self.parse_comma_separated_exprs()!
        Call{target, args, meta: self.meta(mark)}
    end

    fn parse_comma_separated_exprs(mut self) Vector<Expr> throws ParseError:
        let exprs = Vector<Expr>.new()
        mut got_comma = false
        loop:
            let next_token = self.iter.force_next()!
            match next_token.kind:
                TokenKind.RParen => break
                TokenKind.Comma:
                    if got_comma => return parse_error(ExprExpected(next_token), next_token)
                    got_comma = true
                    continue
                end
                _: 
                    if exprs.len() > 0 and not got_comma => 
                        return parse_error(UnexpectedToken(next_token), next_token)
                    got_comma = false
                    match self.parse_expr(next_token)!:
                        Some<Expr>(expr) => exprs.push(expr)
                        None => return parse_error(ExprExpected(next_token), next_token)
                    end
                end
            end
        end
        exprs
    end

    fn parse_block(mut self) Block throws ParseError:
        -- todo (lang-feat): We should be able to use named arguments here. And we should
        --                   be able to force the use of named arguments.
        self.parse_block_advanced(false)!.0
    end

    fn parse_block_advanced(mut self, may_end_with_else Bool) (Block, Bool) throws ParseError:
        --- Parse a block starting with either `=>` or `:`. The `may_end_with_else` parameter
            indicates whether the block may end with an `else` token.

            @return A tuple containing the block and a boolean indicating whether the block
                    ended with an `else` token.
        ---
        let mark = self.iter.mark()
        let items = Vector<BlockItem>.new() 
        let next_token = self.iter.force_next()!
        mut ended_with_else = false
        match next_token.kind:
            TokenKind.FatArrow:
                -- This is a signle expression block, an expression has to follow.
                match self.parse_expr(self.iter.force_next()!)!:
                    Some<Expr>(expr) => items.push(BlockItem.Expr(expr))
                    None => return parse_error(
                        ExprExpected(self.iter.force_next()!), self.iter.force_next()!
                    )
                end
            end
            TokenKind.Colon:
                -- This is a multi-line block that may contain things other than expressions.
                loop:
                    let token = self.iter.force_next()!
                    let item = match token.kind:
                        TokenKind.End => break
                        TokenKind.Else:
                            if not may_end_with_else => 
                                return parse_error(UnexpectedToken(token), token)
                            ended_with_else = true
                            break
                        end
                        _ => self.parse_block_item(token)!
                    end
                    items.push(item)
                end
            end
            _ => return parse_error(UnexpectedToken(next_token), next_token)
        end
        -- todo: The `return` should not be needed here. The stage0 parser
        --       cannot distinguish between a call and a tuple type here.
        return (Block{meta: self.meta(mark), items}, ended_with_else)
    end

    fn parse_block_item(mut self, token Token) BlockItem throws ParseError:
        let expr = self.parse_expr(token)!
        if expr.is_some() => return BlockItem.Expr(expr.unwrap())
        let item = self.parse_item(token)!
        if item.is_none() => return parse_error(UnexpectedToken(token), token)
        match item.unwrap():
            ParseItem.Fn(f) => BlockItem.Fn(f)
            ParseItem.Trait(t) => BlockItem.Trait(t)
            ParseItem.Enum(e) => BlockItem.Enum(e)
            ParseItem.Impl(i) => BlockItem.Impl(i)
            ParseItem.Struct(i) => BlockItem.Struct(i)
            _ => return parse_error(UnexpectedToken(token), token)
        end
    end

    fn meta(self, mark Int) Meta:
        Meta.new(self.iter.tokens_since(mark))
    end

    fn meta_from_token(self, token Token) Meta:
        Meta.new(Vector<Token>.from([token]))
    end
end

fn parse_error(kind ParseErrorKind, token Token?) Error<(), ParseError>:
    let tokens = if token.is_some() => Vector<Token>.from([token.unwrap()]) else => Vector<Token>.new()
    Error(ParseError{meta: Meta.new(tokens), kind})
end

enum ParseItem:
    --- All items that can be declared anywhere in the source code.
        Returned by `Parser.parse_item`.
    ---
    Fn(Fn)
    FnDecl(FnDecl)
    Trait(Trait)
    Impl(Impl)
    Enum(Enum)
    Struct(Struct)
end

impl ToDebugStr for ParseItem:
    fn to_debug_str(self) Str:
        match self:
            ParseItem.Fn(f) => f.to_debug_str()
            ParseItem.FnDecl(f) => f.to_debug_str()
            ParseItem.Impl(i) => i.to_debug_str()
            ParseItem.Trait(t) => t.to_debug_str()
            ParseItem.Enum(e) => e.to_debug_str()
            ParseItem.Struct(s) => s.to_debug_str()
        end
    end
end

