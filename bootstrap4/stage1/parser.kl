--- = Parser 
    The parse parses a stream of tokens into a high level AST.

    == Desugaring

    Some of the syntactic sugar in the language will be converted
    to their canonical form by the parser:

    - `throws` will convert the return type to `Result<T, Error>`
      as well as converting the return expression (both explicit and implicit)
      to `Ok(expr)`.
    - `<type>?` will convert to `Option<type>` as well as converting
      the return expression (both explicit and implicit) to `Some(expr)`.
      All optional call arguments will be converted to `Some(expr)` as well.

    `Item.is_synthetic` is used to indicate whether the item
    has been altered by the parser as part of desugaring.

    == TODO: Ambiguity

    These constructs are still ambiguous:

    - `if true => return func()`
        - Is this a return statement or a return expression? 
          Writing it as `if true: return end func()` or
          `if true: return func() end` would make it unambiguous.
        - We could remove the ambiguity here by requiring a return
          value in any case. The above would then be written as
          `if true => return () func()` which would be unambiguous.
---
use .ast.Assignment
use .ast.BinaryExpr
use .ast.BinaryExprKind
use .ast.Block
use .ast.BlockItem
use .ast.Call
use .ast.Expr
use .ast.FStr
use .ast.Fn
use .ast.FnDecl
use .ast.GenericArg
use .ast.Ident
use .ast.If
use .ast.Let
use .ast.Literal
use .ast.LiteralKind
use .ast.Meta
use .ast.Module
use .ast.ModuleItem
use .ast.Name
use .ast.NameSegment
use .ast.Param
use .ast.ParseError
use .ast.ParseErrorKind
use .ast.ToDebugStr
use .ast.Type
use .ast.TypeKind
use .ast.UnaryExpr
use .ast.UnaryExprKind
use .lexer.FStrItem
use .lexer.Token
use .lexer.TokenKind

use ParseErrorKind.*

struct TokenIter:
    --- An iterator over tokens that can be peeked and rewound.
    ---
    tokens Vector<Token>
    peeked Token?
    idx Int
end

impl Iterator<Token> for TokenIter:
    fn next(mut self) Token?:
        --- Return the next token or `None` ignoring whitespace and comments.
        ---
        loop:
            let token = self.immediate()
            match token:
                Some(
                    Token{kind: TokenKind.WhiteSpace(_) | TokenKind.Comment(_), span: _}
                ) => continue
                _ => return token
            end
        end
        -- todo (lang-feat): Semantic analysis should be able to infer that this is unreachable.
        None
    end

    fn immediate(mut self) Token?:
        --- Return the next token or `None` but including whitespace and comments.
        ---
        if self.idx >= self.tokens.len() => return None
        let v = if self.peeked.is_some():
            let value = self.peeked.unwrap()
            self.peeked = None
            value
        else:
            let value = self.tokens[self.idx]
            value
        end
        self.idx = self.idx + 1
        v
    end

    fn peek(mut self) Token?:
        --- Peek the next token (ignoring whitespace and comments).
        ---
        loop:
            let token = self.peek_immediate()
            match token:
                Some(
                    Token{kind: TokenKind.WhiteSpace(_) | TokenKind.Comment(_), span: _}
                ) => self.immediate()
                _ => return token
            end
        end
        None
    end

    fn peek_immediate(mut self) Token?:
        --- Peek the next token (including whitespace and comments).
        ---
        if self.peeked.is_some() => return self.peeked
        if self.idx >= self.tokens.len() => return None
        let value = self.tokens[self.idx]
        self.peeked = Some(value)
        value
    end

    fn force_next(mut self) Token throws ParseError:
        --- Return the next token (excluding whitespace and commetns) or 
            an error if there are no more tokens.
        ---
        match self.next():
            Some<Token>(token) => Ok(token)
            None => return parse_error(UnexpectedEOF, None)
        end
    end

    fn force_immediate(mut self) Token throws ParseError:
        --- Return the next token (including whitespace and comments) or 
            an error if there are no more tokens.
        ---
        match self.immediate():
            Some<Token>(token) => Ok(token)
            None => return parse_error(UnexpectedEOF, None)
        end
    end

    fn mark(self) Int => self.idx 

    fn mark_prev(self) Int => self.idx - 1

    fn reset(mut self, mark Int):
        self.peeked = None
        self.idx = mark
    end

    fn tokens_since(mut self, mark Int) Vector<Token>:
        --- Returns all tokens since the given mark (inclusive).
        ---
        if mark >= self.idx or mark < 0 => return Vector<Token>.new()
        self.tokens.slice_copy(mark, self.idx)
    end

    fn expect_ident(mut self) Str throws ParseError:
        --- Expect the next token (without whitespace and comments) to be an identifier.
        ---
        match self.force_next()!:
            Token{kind: TokenKind.Ident(name), span: _ } => Ok(name)
            token => return parse_error(UnexpectedToken(token), token)
        end
    end

    fn expect_token(mut self, predicate (fn(Token) Bool)) Token throws ParseError:
        --- Expect the next token (without whitespace and comments) to match the given predicate.
        ---
        let token = self.force_next()!
        if not predicate(token) => return parse_error(UnexpectedToken(token), token)
        token
    end

    fn expect_lexical_token(mut self, kind TokenKind) Token throws ParseError:
        --- Expect the next token (without whitespace and comments) to match the given kind.
        ---
        self.expect_token(fn(token Token) Bool => token.kind == kind)!
    end

    fn expect_immediate_token(mut self, predicate (fn(Token) Bool)) Token throws ParseError:
        --- Expect the next token (including whitespace and comments) to match the given predicate.
        ---
        let token = self.force_immediate()!
        if not predicate(token) => return parse_error(UnexpectedToken(token), token)
        token
    end

    fn expect_immediate_lexical_token(mut self, kind TokenKind) Token throws ParseError:
        --- Expect the next token (including whitespace and comments) to match the given kind.
        ---
        self.expect_immediate_token(fn(token Token) Bool => token.kind == kind)!
    end
end

impl TokenIter:
    fn new(tokens Vector<Token>) TokenIter:
        TokenIter{tokens, peeked: None, idx: 0}
    end
end

struct Parser:
    iter TokenIter
end

impl Parser:

    fn new(iter TokenIter) Parser:
        Parser{iter}
    end

    fn parse_module(mut self) Module throws ParseError:
        -- The main entry point to parse a Klar module.
        let mark = self.iter.mark()
        let items = Vector<ModuleItem>.new()
        loop:
            let token_option = self.iter.next()
            if token_option.is_none() => break
            let token = token_option.unwrap()
            let item_option = self.parse_item(token)!
            if item_option.is_none() => return parse_error(UnexpectedToken(token), token) 
            let item = item_option.unwrap()
            items.push(
                match item:
                    ParseItem.Fn(f) => ModuleItem.Fn(f)
                end
            )
        end
        Module{items, meta: self.meta(mark)}
    end

    fn parse_item(mut self, token Token) ParseItem? throws ParseError:
        match token.kind:
            TokenKind.Fn => ParseItem.Fn(self.parse_fn_def(token)!)
            _ => return None
        end
    end

    fn parse_type(mut self, token Token) Type throws ParseError:
        let mark = self.iter.mark_prev()
        let kind = match token.kind:
            TokenKind.Ident(name) => TypeKind.Name(self.parse_name(token)!)
            _ => return parse_error(UnexpectedToken(token), token)
        end
        Type{kind, meta: self.meta(mark)}
    end


    fn parse_expr(mut self, token Token) Expr? throws ParseError:
        self.parse_binary_expr(token, 1)!
    end

    fn parse_binary_expr(mut self, token Token, min_prec Int) Expr? throws ParseError:
        --- Parse a binary expression with precedence `min_prec` or higher.
            Each binary operator has a precedence. The higher the precedence
            the tighter the binding. For example, `1 + 2 * 3` is parsed as
            `1 + (2 * 3)` because `*` has a higher precedence than `+`.

            If the operator is the assignment operator `=` then it will
            be parsed as an assignment expression. The precedence of the
            assignment is the lowest possible precedence.
        ---
        let mark = self.iter.mark_prev()
        let expr = self.parse_primary_expr(token)!
        if expr.is_none() => return None
        mut lhs = expr.unwrap()
        loop:
            let op_token = self.iter.peek()
            if op_token.is_none() => break
            let kind_and_prec = match op_token.unwrap().kind:
                None => break
                TokenKind.Equal => return self.parse_assignment(lhs, mark)!
                TokenKind.Or => (BinaryExprKind.Or, 1)
                TokenKind.And => (BinaryExprKind.And, 2)
                TokenKind.DoubleEqual => (BinaryExprKind.Equal, 3)
                TokenKind.NotEqual => (BinaryExprKind.NotEqual, 3)
                TokenKind.LessThan => (BinaryExprKind.LessThan, 4)
                TokenKind.LessThanOrEqual => (BinaryExprKind.LessThanOrEqual, 4)
                TokenKind.GreaterThan => (BinaryExprKind.GreaterThan, 4)
                TokenKind.GreaterThanOrEqual => (BinaryExprKind.GreaterThanOrEqual, 4)
                TokenKind.Plus => (BinaryExprKind.Add, 5)
                TokenKind.Minus => (BinaryExprKind.Sub, 5)
                TokenKind.Star => (BinaryExprKind.Mul, 6)
                TokenKind.Slash => (BinaryExprKind.Div, 6)
                _ => break
            end
            -- todo (lang-feat): We should be able to destruct the tuple.
            let kind = kind_and_prec.0
            let prec = kind_and_prec.1
            if prec < min_prec => break
            self.iter.next()
            let rhs_token = self.iter.force_next()!
            let rhs = self.parse_binary_expr(rhs_token, prec + 1)!
            if rhs.is_none() => return parse_error(ExprExpected(rhs_token), rhs_token)
            lhs = Expr.BinaryExpr(BinaryExpr{kind, lhs, rhs: rhs.unwrap(), meta: self.meta(mark)})
        end
        lhs
    end

    fn parse_primary_expr(mut self, token Token) Expr? throws ParseError:
        let mark = self.iter.mark_prev()
        mut expr = match token.kind:
            TokenKind.IntLiteral(i) => Expr.Literal(self.parse_int_literal(i, token)!)
            TokenKind.BoolLiteral(b) => 
                Expr.Literal(Literal{kind: LiteralKind.BoolLiteral(b), meta: self.meta(mark)})
            TokenKind.StrLiteral(s, _) => 
                Expr.Literal(Literal{kind: LiteralKind.StrLiteral(s), meta: self.meta(mark)})
            TokenKind.LParen => self.parse_unit_or_tuple_literal_or_parentheses(token)!
            TokenKind.Ident(name) => Expr.Ident(self.parse_ident(token)!)
            TokenKind.If => Expr.If(self.parse_if(token)!)
            TokenKind.FStr(items, _) => Expr.FStr(self.parse_fstr(items)!)
            TokenKind.Let => Expr.Let(self.parse_let_or_mut(token)!)
            TokenKind.Mut => Expr.Let(self.parse_let_or_mut(token)!)
            _:
                let unary_expr = self.parse_unary_expr(token)!
                match unary_expr:
                    Some<UnaryExpr>(x) => Expr.UnaryExpr(x)
                    None => return None
                end
            end
        end
        loop:
            expr = match self.iter.peek_immediate():
                Some(Token{kind: TokenKind.LParen, span: _}) => 
                    Expr.Call(self.parse_call(expr)!)
                _ => break
            end
        end
        expr
    end

    fn parse_unary_expr(mut self, token Token) UnaryExpr? throws ParseError:
        let mark = self.iter.mark_prev()
        let kind = match token.kind:
            TokenKind.Minus => UnaryExprKind.Neg
            TokenKind.Not => UnaryExprKind.Not
            _ => return None
        end
        let expr_token = self.iter.force_next()!
        let expr = self.parse_primary_expr(expr_token)!
        match expr:
            -- todo: We are note able to reuse the name `expr` here, the stage0 compiler
            --       throws a JS error.
            Some(x) => UnaryExpr{kind, expr: x, meta: self.meta(mark)}
            None => return parse_error(ExprExpected(expr_token), expr_token)
        end
    end

    fn parse_ident(mut self, token Token) Ident throws ParseError:
        let mark = self.iter.mark_prev()
        match token.kind:
            TokenKind.Ident(name) => Ident{name, meta: self.meta(mark)}
            _ => return parse_error(IdentExpected(token), token)
        end
    end

    fn parse_name(mut self, token Token) Name throws ParseError:
        let root_mark = self.iter.mark_prev()
        let segments = Vector<NameSegment>.new()
        -- The first part of the name must be an identifier.
        match token.kind:
            TokenKind.Ident(name) => 
                segments.push(NameSegment{
                    ident: Ident{name, meta: self.meta(root_mark)},
                    args: None,
                    meta: self.meta(root_mark)
                })
            _ => return parse_error(IdentExpected(token), token)
        end
        -- todo: parse generic arguments and more segments.
        Name{segments, meta: self.meta(root_mark)}
    end

    fn parse_let_or_mut(mut self, token Token) Let throws ParseError:
        --- Parse a `let` or `mut` declaration depending on the given token.
        ---
        let mark = self.iter.mark_prev()
        let is_mut = token.kind == TokenKind.Mut
        let ident = self.parse_ident(self.iter.force_next()!)!
        let type_or_eq = self.iter.force_next()!
        let type = match type_or_eq.kind:
            TokenKind.Equal => Type{kind: TypeKind.Infer, meta: self.meta_from_token(type_or_eq)}
            _: 
                let t = self.parse_type(type_or_eq)! 
                self.iter.expect_lexical_token(TokenKind.Equal)!
                t
            end
        end
        let expr_token = self.iter.force_next()!
        match self.parse_expr(expr_token)!:
            Some<Expr>(expr) => 
                Let{ident, is_mut, type, expr, meta: self.meta(mark)}
            None => return parse_error(ExprExpected(expr_token), expr_token)
        end
    end

    fn parse_if(mut self, token Token) If throws ParseError:
        let mark = self.iter.mark_prev()
        let cond_token = self.iter.force_next()!
        let cond = match self.parse_expr(cond_token)!:
            Some(expr) => expr
            None => return parse_error(ExprExpected(cond_token), cond_token)
        end
        let then_block = self.parse_block_advanced(true)!
        let else_block Block? = 
            if then_block.1:
                Some(self.parse_block()!)
            else:
                -- todo: The assignment to `block` should not be needed here. The stage0 type-checker
                --       cannot infer the type of the match expression.
                let block = match self.iter.peek():
                    Some(Token{kind: TokenKind.Else, span: _}):
                        self.iter.force_next()!
                        Some(self.parse_block()!)
                    end
                    _ => None
                end
                block
            end
        If{cond, then_block: then_block.0, else_block, meta: self.meta(mark)}
    end

    fn parse_int_literal(self, value Str, token Token) Literal throws ParseError:
        let mark = self.iter.mark_prev()
        match Int.from_str(value, 10):
            Ok<Int>(i) => Literal{kind: LiteralKind.IntLiteral(i), meta: self.meta(mark)}
            -- todo: The `return` should not be needed here. The stage0 type-checker
            --       cannot infer that the result of the match is the return value 
            --       of the function.
            Error(_) => return parse_error(InvalidIntLiteral(token), token)
        end
    end

    fn parse_unit_or_tuple_literal_or_parentheses(mut self, token Token) Expr throws ParseError:
        let mark = self.iter.mark_prev()
        let immediate = self.iter.peek_immediate()
        if immediate.is_some() and immediate.unwrap().kind == TokenKind.RParen => 
            return Expr.Literal(Literal{kind: LiteralKind.UnitLiteral, meta: self.meta(mark)})
        let exprs = self.parse_comma_separated_exprs()!
        if exprs.len() == 1 => return exprs[0]
        return parse_error(UnexpectedToken(immediate.unwrap()), immediate.unwrap())
    end

    fn parse_fstr(mut self, items Vector<FStrItem>) FStr throws ParseError:
        let mark = self.iter.mark_prev()
        mut exprs = Vector<Expr>.new()
        mut idx = 0
        -- todo (lang-feat): We tried to implement this with `items.iter().map()` but
        --                   we were not able to propagate errors from the map closure.
        loop:
            if idx >= items.len() => break
            let item = items[idx]
            idx = idx + 1
            let expr = match item:
                FStrItem.FStrTokensItem(tokens):
                    mut parser = Parser.new(TokenIter.new(tokens))
                    let expr = parser.parse_expr(parser.iter.force_next()!)!
                    match expr:
                        Some<Expr>(value) => value
                        None => return parse_error(ExprExpected(tokens[0]), tokens[0])
                    end
                end
                FStrItem.FStrStrItem(s):
                    Expr.Literal(Literal{kind: LiteralKind.StrLiteral(s), meta: self.meta(mark)})
                end
            end
            exprs.push(expr)
        end
        FStr{exprs, meta: self.meta(mark)}
    end

    fn parse_assignment(mut self, lhs Expr, mark Int) Expr throws ParseError:
        self.iter.expect_lexical_token(TokenKind.Equal)!
        let rhs_token = self.iter.force_next()!
        let rhs = self.parse_expr(rhs_token)!
        if rhs.is_none() => return parse_error(ExprExpected(rhs_token), rhs_token)
        Expr.Assignment(Assignment{ lhs, rhs: rhs.unwrap(), meta: self.meta(mark) })
    end

    fn parse_fn_decl(mut self, token Token) FnDecl throws ParseError:
        let mark = self.iter.mark_prev()
        let ident = self.parse_ident(self.iter.force_next()!)!
        self.iter.expect_lexical_token(TokenKind.LParen)!
        let params = Vector<Param>.new()
        let return_type = Type{kind: TypeKind.Unit, meta: self.meta(mark)}
        self.iter.expect_lexical_token(TokenKind.RParen)!
        FnDecl{ident, params, return_type, meta: self.meta(mark)}
    end

    fn parse_fn_def(mut self, token Token) Fn throws ParseError: 
        let mark = self.iter.mark_prev()
        let decl = self.parse_fn_decl(token)!
        let body = self.parse_block()!
        Fn{decl, body, meta: self.meta(mark)}
    end

    fn parse_call(mut self, target Expr) Call throws ParseError:
        let mark = self.iter.mark()
        self.iter.expect_immediate_lexical_token(TokenKind.LParen)!
        let args = self.parse_comma_separated_exprs()!
        Call{target, args, meta: self.meta(mark)}
    end

    fn parse_comma_separated_exprs(mut self) Vector<Expr> throws ParseError:
        let exprs = Vector<Expr>.new()
        mut got_comma = false
        loop:
            let next_token = self.iter.force_next()!
            match next_token.kind:
                TokenKind.RParen => break
                TokenKind.Comma:
                    if got_comma => return parse_error(ExprExpected(next_token), next_token)
                    got_comma = true
                    continue
                end
                _: 
                    if exprs.len() > 0 and not got_comma => 
                        return parse_error(UnexpectedToken(next_token), next_token)
                    got_comma = false
                    match self.parse_expr(next_token)!:
                        Some<Expr>(expr) => exprs.push(expr)
                        None => return parse_error(ExprExpected(next_token), next_token)
                    end
                end
            end
        end
        exprs
    end

    fn parse_block(mut self) Block throws ParseError:
        -- todo (lang-feat): We should be able to use named arguments here. And we should
        --                   be able to force the use of named arguments.
        self.parse_block_advanced(false)!.0
    end

    fn parse_block_advanced(mut self, may_end_with_else Bool) (Block, Bool) throws ParseError:
        let mark = self.iter.mark()
        let items = Vector<BlockItem>.new() 
        let next_token = self.iter.force_next()!
        mut ended_with_else = false
        match next_token.kind:
            TokenKind.FatArrow:
                -- This is a signle expression block, an expression has to follow.
                match self.parse_expr(self.iter.force_next()!)!:
                    Some<Expr>(expr) => items.push(BlockItem.Expr(expr))
                    None => return parse_error(
                        ExprExpected(self.iter.force_next()!), self.iter.force_next()!
                    )
                end
            end
            TokenKind.Colon:
                -- This is a multi-line block that may contain things other than expressions.
                loop:
                    let token = self.iter.force_next()!
                    let item = match token.kind:
                        TokenKind.End => break
                        TokenKind.Else:
                            if not may_end_with_else => 
                                return parse_error(UnexpectedToken(token), token)
                            ended_with_else = true
                            break
                        end
                        _ => self.parse_block_item(token)!
                    end
                    items.push(item)
                end
            end
            _ => return parse_error(UnexpectedToken(next_token), next_token)
        end
        -- todo: The `return` should not be needed here. The stage0 parser
        --       cannot distinguish between a call and a tuple type here.
        return (Block{meta: self.meta(mark), items}, ended_with_else)
    end

    fn parse_block_item(mut self, token Token) BlockItem throws ParseError:
        let expr = self.parse_expr(token)!
        if expr.is_some() => return BlockItem.Expr(expr.unwrap())
        let item = self.parse_item(token)!
        if item.is_none() => return parse_error(UnexpectedToken(token), token)
        match item.unwrap():
            ParseItem.Fn(f) => BlockItem.Fn(f)
            _ => return parse_error(UnexpectedToken(token), token)
        end
    end

    fn meta(self, mark Int) Meta:
        Meta.new(self.iter.tokens_since(mark))
    end

    fn meta_from_token(self, token Token) Meta:
        Meta.new(Vector<Token>.from([token]))
    end
end

fn parse_error(kind ParseErrorKind, token Token?) Error<(), ParseError>:
    let tokens = if token.is_some() => Vector<Token>.from([token.unwrap()]) else => Vector<Token>.new()
    Error(ParseError{meta: Meta.new(tokens), kind})
end

enum ParseItem:
    --- All items that can be declared anywhere in the source code.
        Returned by `Parser.parse_item`.
    ---
    Fn(Fn)
end

impl ToDebugStr for ParseItem:
    fn to_debug_str(self) Str:
        match self:
            ParseItem.Fn(f) => f.to_debug_str()
        end
    end
end

