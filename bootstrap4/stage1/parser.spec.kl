use .lexer::Lexer
use .lexer::Token
use .parser::Parser
use .parser::TokenIter
use .parser::ParseItem
use .ast::ParseError
use .ast::ToDebugStr
use .ast::Expr
use .test::Test

fn main():
    mut test = Test::new_from_args("parser", env.args)

    test.it("ignores comments and whitespace", fn() throws:
        assert(expr("\n 42 -- comment") == "(@int 42)")
    end)

    test.it("parses identifiers", fn() throws:
        -- todo: do we really need `Ident` when we have `FQN`?
        assert(expr("a") == "(@ident a)")
        assert(expr("a42") == "(@ident a42)")
        assert(expr("a_42") == "(@ident a_42)")
    end)

    test.group("fully qualified names", fn():
        test.it("passes the happy path", fn() throws:
            assert(
                expr("A<T>") 
                == 
                "(@fqn (@name (@ident A) (@genericarg (@type (@fqn (@name (@ident T)))))))"
            )
            assert(expr("a::b") == "(@fqn (@name (@ident a)) (@name (@ident b)))")
            assert(
                expr("A<B>::C<D>") 
                == 
                "(@fqn (@name (@ident A) (@genericarg (@type (@fqn (@name (@ident B)))))) " + 
                "(@name (@ident C) (@genericarg (@type (@fqn (@name (@ident D)))))))"
            )
        end)

        test.it("distinguishes generics from the less-than operator", fn() throws:
            assert(expr("a < b") == "(@binexpr < (@ident a) (@ident b))")
        end)

        test.it("parses generics", fn() throws:
            assert(
                expr("A<B>") 
                == 
                "(@fqn (@name (@ident A) (@genericarg (@type (@fqn (@name (@ident B)))))))"
            )
        end)

        test.it("parses generics with multiple arguments", fn() throws:
            assert(
                expr("A<B, C>") 
                == 
                "(@fqn (@name (@ident A) " +
                "(@genericarg (@type (@fqn (@name (@ident B))))) " +
                "(@genericarg (@type (@fqn (@name (@ident C)))))))"
            )
        end)

        test.it("parses generics with trait bounds", fn() throws:
            assert(
                expr("A<B impl C>") 
                == 
                "(@fqn (@name (@ident A) " +
                "(@genericarg (@type (@fqn (@name (@ident B)))) " +
                "(@traitbound (@fqn (@name (@ident C)))))))"
            )
        end)

        test.it("parses generics with multiple trait bounds", fn() throws:
            assert(
                expr("A<B impl C and D>") 
                == 
                "(@fqn (@name (@ident A) " +
                "(@genericarg (@type (@fqn (@name (@ident B)))) " +
                "(@traitbound (@fqn (@name (@ident C)))) " +
                "(@traitbound (@fqn (@name (@ident D)))))))"
            )
        end)
    end)

    test.group("blocks", fn():
        test.it("parses multi-line blocks", fn() throws:
            assert(block(": end") == "(@block)")
            assert(block(": 42 end") == "(@block (@int 42))")
            assert(block(": foo() 42 end") == "(@block (@call (@ident foo)) (@int 42))")
        end)

        test.it("parses items (like Fn) in multi-line blocks", fn() throws:
            assert(
                block(": fn test(): end end") 
                == 
                "(@block (@fn (@fndecl (@ident test) (@type (@unit))) (@block)))"
            )
        end)

        test.it("parses single-line blocks", fn() throws:
            assert(block("=> 42") == "(@block (@int 42))")
            assert(block("=> foo() 42") == "(@block (@call (@ident foo)))")
        end)
    end)

    test.group("fndecl", fn():
        test.it("passes the happy path", fn() throws:
            assert(fndecl("fn test()") == "(@fndecl (@ident test) (@type (@unit)))")
        end)

        test.it("parses parameters", fn() throws:
            assert(
                fndecl("fn test(a Int)") 
                == 
                "(@fndecl (@ident test) " +
                "(@param (@ident a) (@type (@fqn (@name (@ident Int))))) " +
                "(@type (@unit)))"
            )
            assert(
                fndecl("fn test(a Int, b Str)") 
                == 
                "(@fndecl (@ident test) " + 
                "(@param (@ident a) (@type (@fqn (@name (@ident Int))))) " +
                "(@param (@ident b) (@type (@fqn (@name (@ident Str))))) " +
                "(@type (@unit)))"
            )
        end)

        test.it("parses mutable parameters", fn() throws:
            assert(
                fndecl("fn test(mut a Int)") 
                == 
                "(@fndecl (@ident test) " +
                "(@param mut (@ident a) (@type (@fqn (@name (@ident Int))))) " +
                "(@type (@unit)))"
            )
        end)

        test.it("parses the `self` parameter", fn() throws:
            assert(
                item("fn test(self): end") 
                == 
                "(@fn (@fndecl (@ident test) " +
                "(@param (@ident self) (@type (@self))) " +
                "(@type (@unit))) (@block))"
            )
        end)

        test.it("parses the mutable `self` parameter", fn() throws:
            assert(
                item("fn test(mut self): end") 
                == 
                "(@fn (@fndecl (@ident test) " +
                "(@param mut (@ident self) (@type (@self))) " +
                "(@type (@unit))) (@block))"
            )
        end)

        test.it("parses generics", fn() throws:
            assert(
                fndecl("fn test<T>()") 
                == 
                "(@fndecl (@ident test) " +
                "(@genericarg (@type (@fqn (@name (@ident T))))) " +
                "(@type (@unit)))"
            )
        end)

        test.it("parses function type as parameter", fn() throws:
            assert(
                fndecl("fn test(a (fn(Int) Int))") 
                == 
                "(@fndecl (@ident test) " +
                "(@param (@ident a) " +
                "(@fntype " +
                "(@type (@fqn (@name (@ident Int)))) " +
                "(@type (@fqn (@name (@ident Int)))))) " +
                "(@type (@unit)))"
            )
        end)

        test.group("throws", fn():
            test.it("passes the happy path", fn() throws:
                assert(
                    fndecl("fn test() throws") 
                    == 
                    "(@fndecl (@ident test) " +
                    "(@type (@fqn (@name (@ident Result) " +
                    "(@genericarg (@type (@unit))) " +
                    "(@genericarg (@type (@fqn (@name (@ident Str)))))))))"
                )
            end)

            test.it("parses the return type", fn() throws:
                assert(
                    fndecl("fn test() Int throws") 
                    == 
                    "(@fndecl (@ident test) " +
                    "(@type (@fqn (@name (@ident Result) " +
                    "(@genericarg (@type (@fqn (@name (@ident Int))))) " +
                    "(@genericarg (@type (@fqn (@name (@ident Str)))))))))"
                )
            end)

            test.it("parses error types", fn() throws:
                assert(
                    fndecl("fn test() Int throws MyError") 
                    == 
                    "(@fndecl (@ident test) " +
                    "(@type (@fqn (@name (@ident Result) " +
                    "(@genericarg (@type (@fqn (@name (@ident Int))))) " +
                    "(@genericarg (@type (@fqn (@name (@ident MyError)))))))))"
                )
            end)

        end)
    end)

    test.group("fn", fn():
        test.it("passes the happy path", fn() throws:
            assert(
                item("fn test(): end") 
                == 
                "(@fn (@fndecl (@ident test) (@type (@unit))) (@block))"
            )
            assert(
                item("fn test(): 42 end") 
                == 
                "(@fn (@fndecl (@ident test) (@type (@unit))) (@block (@int 42)))"
            )
        end)
    end)

    test.group("closures", fn():
        test.it("passes the happy path", fn() throws:
            assert(
                expr("fn(a Int) Int => 42") 
                == 
                "(@closure (@param (@ident a) (@type (@fqn (@name (@ident Int))))) " +
                "(@type (@fqn (@name (@ident Int)))) (@block (@int 42)))"
            )
        end)

        test.it("treats types as optional", fn() throws:
            assert(
                expr("fn(a) => 42") 
                == 
                "(@closure (@param (@ident a) (@type (@infer))) " +
                "(@type (@infer)) (@block (@int 42)))"
            )
        end)

        test.it("parses the `throws` keyword", fn() throws:
            assert(
                expr("fn() throws => 42") 
                == 
                "(@closure " +
                "(@type (@fqn (@name (@ident Result) " +
                "(@genericarg (@type (@unit))) " +
                "(@genericarg (@type (@fqn (@name (@ident Str)))))))) " +
                "(@block (@int 42)))"
            )
        end)
    end)

    test.group("literals", fn():
        test.it("parses unit literals", fn() throws:
            assert(expr("()") == "(@unit)")
            assert(expr("return ()") == "(@return (@unit))")
        end)

        test.it("parses unit literals only if `(` is immediately followed by `)`", fn() throws:
            -- It's not required for ambiguity reasons, but having whitespace in between
            -- obscures the intent of the code.
            assert(expr("( )") == "(@error unexpected token `WhiteSpace()` at test.kl:1:2)")
        end)

        test.it("parses boolean literals", fn() throws:
            assert(expr("true") == "(@bool true)")
            assert(expr("false") == "(@bool false)")
        end)

        test.it("parses string literals", fn() throws:
            assert(expr("\"\"") == "(@str)")
            assert(expr("\"\"\"foo\nbar\"\"\"") == "(@str foo\\nbar)")
        end)

        test.it("parses char literals", fn() throws:
            assert(expr("'a'") == "(@char a)")
        end)

        test.group("int", fn():
            test.it("passes the happy path", fn() throws:
                assert(expr("42") == "(@int 42)")
                assert(expr("-42") == "(@int -42)")
            end)

            test.it("detects integer overflow", fn() throws:
                -- todo: for now `Int` is defined as 32-but, but it should be 
                --       the platform's native int size (64-bit in most cases).
                assert(expr("2147483647") == "(@int 2147483647)")
                assert(expr("2147483648") == "(@error invalid int literal at test.kl:1:1)")
                assert(expr("-2147483648") == "(@int -2147483648)")
                assert(expr("-2147483649") == "(@error invalid int literal at test.kl:1:1)")
            end)
        end)

        test.it("parses tuple literals", fn() throws:
            assert(expr("(42, \"a\")") == "(@tuple (@int 42) (@str a))")
        end)

        test.group("array", fn():
            test.it("passes the happy path", fn() throws:
                assert(expr("[42, \"foo\"]") == "(@array (@int 42) (@str foo))")
            end)

            test.it("parses empty arrays", fn() throws:
                assert(expr("[]") == "(@array)")
            end)
        end)
    end)

    test.group("f-string", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("f\"\"") == "(@fstr)")
            assert(expr("f\"foo\"") == "(@fstr (@str foo))")
            assert(expr("f\"foo {42}\"") == "(@fstr (@str foo ) (@int 42))")
        end)

        test.it("detects errors in f-string expressions", fn() throws:
            -- `for` is a keyword and not an expression.
            assert(expr("f\"{for}\"") == "(@error expr expected at test.kl:1:4-6)")
        end)
    end)

    test.group("calls", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("test()") == "(@call (@ident test))")
            assert(expr("test(42)") == "(@call (@ident test) (@int 42))")
            assert(expr("test(42, 43)") == "(@call (@ident test) (@int 42) (@int 43))")
        end)

        test.it("ignores trailing comma in argument list", fn() throws:
            assert(expr("test(42,)") == "(@call (@ident test) (@int 42))")
            assert(expr("test(42, 43,)") == "(@call (@ident test) (@int 42) (@int 43))")
        end)

        test.it("requires `(` to be an immediate token after the call target", fn() throws:
            -- This is to resolve ambiguity between calls, tuples, and the unit literal.
            assert(expr("test ()") == "(@ident test)")
            assert(expr("test--- comment ---()") == "(@ident test)")
        end)

        test.it("parses calls to functions returned from functions", fn() throws:
            assert(expr("test()()") == "(@call (@call (@ident test)))")
        end)

        test.it("parses chained calls", fn() throws:
            assert(expr("test().foo()") == "(@call (@fieldaccess (@call (@ident test)) (@name (@ident foo))))")
        end)

        test.it("parses generics (if target is a FQN)", fn() throws:
            assert(
                expr("test<Int>()") 
                == 
                "(@call (@fqn (@name (@ident test) (@genericarg (@type (@fqn (@name (@ident Int))))))))"
            )
        end)

        test.it("parses generics (if target is a call expression itself)", fn() throws:
            assert(
                expr("test().foo<Int>()") 
                == 
                "(@call (@fieldaccess (@call (@ident test)) " +
                "(@name (@ident foo) (@genericarg (@type (@fqn (@name (@ident Int))))))))"
            )
        end)

        test.it("parses error propagation with `!`", fn() throws:
            assert(expr("test()!") == "(@call (@ident test) (@propagate))")
        end)
    end)

    test.group("module", fn():
        test.it("passes the happy path", fn() throws:
            assert(
                module("""
                    fn test():
                    end
                    """) 
                == 
                "(@mod (@fn (@fndecl (@ident test) (@type (@unit))) (@block)))"
            )
        end)
    end)

    test.group("types", fn():
        test.it("parses literal type names", fn() throws:
            assert(type("Int") == "(@type (@fqn (@name (@ident Int))))")
        end)

        test.it("parses tuple types", fn() throws:
            assert(type("(Int, Str)") == "(@type (@tuple " +
                "(@type (@fqn (@name (@ident Int)))) " +
                "(@type (@fqn (@name (@ident Str)))))"
            )
        end)

        test.it("parses the unit type", fn() throws:
            assert(type("()") == "(@type (@unit))")
            assert(type("( )") == "(@error type expected at test.kl:1:3)")
        end)

        test.it("parses generic types", fn() throws:
            assert(
                type("Foo<T>") 
                == 
                "(@type (@fqn (@name (@ident Foo) (@genericarg (@type (@fqn (@name (@ident T))))))))"
            )
        end)

        test.it("parses optional types", fn() throws:
            assert(
                type("Int?") 
                == 
                "(@type (@fqn (@name (@ident Option) (@genericarg (@type (@fqn (@name (@ident Int))))))))"
            )
        end)

        test.group("function types", fn():
            test.it("passes the happy path", fn() throws:
                assert(
                    type("(fn(Int, Str) Int)") 
                    == 
                    "(@fntype " + 
                    "(@type (@fqn (@name (@ident Int)))) " +
                    "(@type (@fqn (@name (@ident Str)))) " +
                    "(@type (@fqn (@name (@ident Int)))))"
                )
            end)

            test.it("defaults to the unit type if no return type is specified", fn() throws:
                assert(
                    type("(fn(Int))") 
                    == 
                    "(@fntype (@type (@fqn (@name (@ident Int)))) (@type (@unit)))"
                )
            end)

            test.it("parses the `throws` keyword", fn() throws:
                assert(
                    type("(fn() throws)") 
                    == 
                    "(@fntype (@type (@fqn (@name (@ident Result) " +
                    "(@genericarg (@type (@unit))) " +
                    "(@genericarg (@type (@fqn (@name (@ident Str)))))))))"
                )
            end)
        end)
    end)

    test.group("variable declarations", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("let a Int = 42") == "(@let (@ident a) (@type (@fqn (@name (@ident Int)))) (@int 42))")
        end)

        test.it("does not require a type annotation", fn() throws:
            assert(expr("let a = 42") == "(@let (@ident a) (@type (@infer)) (@int 42))")
        end)

        test.it("respects associativity", fn() throws:
            assert(expr("let a = b or c") == "(@let (@ident a) (@type (@infer)) (@binexpr or (@ident b) (@ident c)))")
        end)

        test.it("parses `mut`", fn() throws:
            assert(expr("mut a = 42") == "(@mut (@ident a) (@type (@infer)) (@int 42))")
        end)
    end)

    test.group("if", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("if true: end") == "(@if (@bool true) (@block))")
            assert(expr("if true: 42 end") == "(@if (@bool true) (@block (@int 42)))")
        end)

        test.it("parses if / else", fn() throws:
            assert(expr("if true: 42 else: 43 end") == "(@if (@bool true) (@block (@int 42)) (@block (@int 43)))")
            assert(expr("if true => 42 else => 43") == "(@if (@bool true) (@block (@int 42)) (@block (@int 43)))")
        end)

        test.it("parses nested if / else", fn() throws:
            assert(expr("""
                if a:
                    if b:
                    end
                else:
                end
                """)
                ==
                "(@if (@ident a) " +
                "(@block (@if (@ident b) (@block))) (@block))"
            )
            assert(expr("""
                if a:
                else:
                    if b => 42
                end
                """)
                ==
                "(@if (@ident a) " +
                "(@block) (@block (@if (@ident b) (@block (@int 42)))))"
            )
        end)
    end)

    test.group("binary expressions", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("1 + 2") == "(@binexpr + (@int 1) (@int 2))")
        end)

        test.it("respects operator precedence", fn() throws:
            assert(expr("1 + 2 * 3") == "(@binexpr + (@int 1) (@binexpr * (@int 2) (@int 3)))")
        end)

        test.it("respects operator associativity (left)", fn() throws:
            assert(expr("1 + 2 + 3") == "(@binexpr + (@binexpr + (@int 1) (@int 2)) (@int 3))")
        end)

        test.it("parses all binary operators", fn() throws:
            assert(expr("1 + 2") == "(@binexpr + (@int 1) (@int 2))")
            assert(expr("1 - 2") == "(@binexpr - (@int 1) (@int 2))")
            assert(expr("1 * 2") == "(@binexpr * (@int 1) (@int 2))")
            assert(expr("1 / 2") == "(@binexpr / (@int 1) (@int 2))")
            assert(expr("1 == 2") == "(@binexpr == (@int 1) (@int 2))")
            assert(expr("1 != 2") == "(@binexpr != (@int 1) (@int 2))")
            assert(expr("1 < 2") == "(@binexpr < (@int 1) (@int 2))")
            assert(expr("1 <= 2") == "(@binexpr <= (@int 1) (@int 2))")
            assert(expr("1 > 2") == "(@binexpr > (@int 1) (@int 2))")
            assert(expr("1 >= 2") == "(@binexpr >= (@int 1) (@int 2))")
            assert(expr("1 and 2") == "(@binexpr and (@int 1) (@int 2))")
            assert(expr("1 or 2") == "(@binexpr or (@int 1) (@int 2))")
        end)

        test.it("respects logical associativity", fn() throws:
            assert(
                expr("1 and 2 or 3 and 4") 
                == 
                "(@binexpr or (@binexpr and (@int 1) (@int 2)) (@binexpr and (@int 3) (@int 4)))"
            )
        end)

        test.it("respects parentheses", fn() throws:
            assert(expr("(1 + 2) * 3") == "(@binexpr * (@binexpr + (@int 1) (@int 2)) (@int 3))")
        end)
    end)

    test.group("unary expressions", fn():
        test.it("parses `not` expressions", fn() throws:
            assert(expr("not true") == "(@unexpr not (@bool true))")
        end)

        test.it("parses `-` (negation) expressions", fn() throws:
            assert(expr("- 42") == "(@unexpr - (@int 42))")
            -- Note: `-2147483648` is a valid int literal, but `- 2147483648` is not, because
            --       the lexer will tokenize it as `-` and `2147483648` (two tokens). So the
            --       parser will try to parse the integer literal, and fail because it's out
            --       of range.
            assert(expr("- 2147483648") == "(@error invalid int literal at test.kl:1:3)")
        end)

        test.it("respects precedence and associativity", fn() throws:
            assert(expr("not true or false") == "(@binexpr or (@unexpr not (@bool true)) (@bool false))")
            assert(expr("not a or not b") == "(@binexpr or (@unexpr not (@ident a)) (@unexpr not (@ident b)))")
            assert(expr("- 42 + 43") == "(@binexpr + (@unexpr - (@int 42)) (@int 43))")
        end)
    end)

    test.group("assignment", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("a = 42") == "(@assign (@ident a) (@int 42))")
        end)

        test.it("respects associativity", fn() throws:
            assert(expr("a = b or c") == "(@assign (@ident a) (@binexpr or (@ident b) (@ident c)))")
        end)
    end)

    test.group("loop", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("loop: end") == "(@loop (@block))")
            assert(expr("loop: 42 end") == "(@loop (@block (@int 42)))")
        end)

        test.it("parses `break`", fn() throws:
            assert(expr("loop: break end") == "(@loop (@block (@break)))")
        end)

        test.it("parses `continue`", fn() throws:
            assert(expr("loop: continue end") == "(@loop (@block (@continue)))")
        end)
    end)

    test.group("trait", fn():
        test.it("passes the happy path", fn() throws:
            assert(
                item("""
                    trait Foo:
                        fn bar()
                    end
                    """) 
                == 
                "(@trait (@name (@ident Foo)) (@fndecl (@ident bar) (@type (@unit))))"
            )
        end)

        test.it("parses generics", fn() throws:
            assert(
                item("""
                    trait Foo<T>:
                        fn bar()
                    end
                    """) 
                == 
                "(@trait (@name (@ident Foo) (@genericarg (@type (@fqn (@name (@ident T)))))) " +
                "(@fndecl (@ident bar) (@type (@unit))))"
            )
        end)

        test.it("parses default implementations", fn() throws:
            assert(
                item("""
                    trait Foo:
                        fn bar()
                        fn baz():
                        end
                    end
                    """) 
                == 
                "(@trait (@name (@ident Foo)) " +
                "(@fndecl (@ident bar) (@type (@unit))) " +
                "(@fn (@fndecl (@ident baz) (@type (@unit))) (@block)))"
            )
        end)

        test.it("is parsed inside blocks", fn() throws:
            assert(
                item("""
                    fn test():
                        trait Foo:
                            fn bar()
                        end
                    end
                    """) 
                == 
                "(@fn (@fndecl (@ident test) (@type (@unit))) " +
                "(@block (@trait (@name (@ident Foo)) (@fndecl (@ident bar) (@type (@unit))))))"
            )
        end)

        test.it("parses trait bounds", fn() throws:
            assert(
                item("""
                    trait Foo impl Bar:
                    end
                    """) 
                == 
                "(@trait (@name (@ident Foo)) (@traitbound (@fqn (@name (@ident Bar)))))"
            )
        end)
    end)

    test.group("enum", fn():
        test.it("passes the happy path", fn() throws:
            assert(
                item("""
                    enum Foo:
                        Bar
                        Baz(Int, Str, Bool)
                    end
                    """) 
                == 
                "(@enum (@name (@ident Foo)) " +
                "(@variant (@ident Bar) (@unit)) " +
                "(@variant (@ident Baz) (@tuple " + 
                "(@type (@fqn (@name (@ident Int)))) " +
                "(@type (@fqn (@name (@ident Str)))) " +
                "(@type (@fqn (@name (@ident Bool)))))))"
            )
        end)

        test.it("parses generics", fn() throws:
            assert(
                item("""
                    enum Foo<T>:
                        Bar
                    end
                    """) 
                == 
                "(@enum (@name (@ident Foo) (@genericarg (@type (@fqn (@name (@ident T)))))) " +
                "(@variant (@ident Bar) (@unit)))"
            )
        end)

        test.it("is parsed inside blocks", fn() throws:
            assert(
                item("""
                    fn test():
                        enum Foo:
                            Bar
                        end
                    end
                    """) 
                == 
                "(@fn (@fndecl (@ident test) (@type (@unit))) " +
                "(@block (@enum (@name (@ident Foo)) " +
                "(@variant (@ident Bar) (@unit)))))"
            )
        end)
    end)

    test.group("impl", fn():
        test.it("passes the happy path", fn() throws:
            assert(
                item("""
                    impl Foo:
                        fn bar():
                        end
                    end
                    """) 
                == 
                "(@impl (@fqn (@name (@ident Foo))) " +
                "(@fn (@fndecl (@ident bar) (@type (@unit))) (@block)))"
            )
        end)

        test.it("parses generics", fn() throws:
            assert(
                item("""
                    impl Foo<T> for Bar<U>:
                        fn bar():
                        end
                    end
                    """) 
                == 
                "(@impl (@fqn (@name (@ident Foo) " +
                "(@genericarg (@type (@fqn (@name (@ident T))))))) " +
                "(@fqn (@name (@ident Bar) (@genericarg (@type (@fqn (@name (@ident U))))))) " +
                "(@fn (@fndecl (@ident bar) (@type (@unit))) (@block)))"
            )
        end)

        test.it("parses trait impls", fn() throws:
            assert(
                item("""
                    impl Foo for Bar:
                        fn foo():
                        end
                    end
                    """) 
                == 
                "(@impl (@fqn (@name (@ident Foo))) " +
                "(@fqn (@name (@ident Bar))) " +
                "(@fn (@fndecl (@ident foo) (@type (@unit))) (@block)))"
            )
        end)

        test.it("is parsed inside blocks", fn() throws:
            assert(
                item("""
                    fn test():
                        impl Foo:
                            fn foo():
                            end
                        end
                    end
                    """) 
                == 
                "(@fn (@fndecl (@ident test) (@type (@unit))) " +
                "(@block (@impl (@fqn (@name (@ident Foo))) " +
                "(@fn (@fndecl (@ident foo) (@type (@unit))) (@block)))))"
            )
        end)
    end)

    test.group("struct", fn():
        test.it("passes the happy path", fn() throws:
            assert(
                item("""
                    struct Foo:
                        a Int
                        b Str
                    end
                    """) 
                == 
                "(@struct (@name (@ident Foo)) " +
                "(@field (@ident a) (@type (@fqn (@name (@ident Int))))) " +
                "(@field (@ident b) (@type (@fqn (@name (@ident Str))))))"
            )
        end)

        test.it("parses generics", fn() throws:
            assert(
                item("""
                    struct Foo<T>:
                        a T
                    end
                    """) 
                == 
                "(@struct (@name (@ident Foo) (@genericarg (@type (@fqn (@name (@ident T)))))) " +
                "(@field (@ident a) (@type (@fqn (@name (@ident T))))))"
            )
        end)

        test.it("is parsed inside blocks", fn() throws:
            assert(
                item("""
                    fn test():
                        struct Foo:
                            a Int
                            b Str
                        end
                    end
                    """) 
                == 
                "(@fn (@fndecl (@ident test) (@type (@unit))) " +
                "(@block (@struct (@name (@ident Foo)) " +
                "(@field (@ident a) (@type (@fqn (@name (@ident Int))))) " +
                "(@field (@ident b) (@type (@fqn (@name (@ident Str))))))))"
            )
        end)
    end)

    test.group("extern", fn():
        test.it("passes the happy path", fn() throws:
            assert(
                module("""
                    extern:
                        fn foo() Int
                    end
                    """) 
                == 
                "(@mod (@extern (@fndecl (@ident foo) (@type (@fqn (@name (@ident Int)))))))" 
            )
        end)

        test.it("parses extern structs", fn() throws:
            assert(
                module("""
                    extern:
                        struct Foo:
                            a Int
                        end
                    end
                    """) 
                == 
                "(@mod (@extern (@struct (@name (@ident Foo)) " +
                "(@field (@ident a) (@type (@fqn (@name (@ident Int))))))))"
            )
        end)

        test.it("parses extern enums", fn() throws:
            assert(
                module("""
                    extern:
                        enum Foo:
                            Bar
                        end
                    end
                    """) 
                == 
                "(@mod (@extern (@enum (@name (@ident Foo)) " +
                "(@variant (@ident Bar) (@unit)))))"
            )
        end)

        test.it("parses trait implementations", fn() throws:
            assert(
                module("""
                    extern:
                        impl Foo for Bar
                    end
                    """) 
                == 
                "(@mod (@extern (@externimpltrait (@fqn (@name (@ident Foo))) " +
                "(@fqn (@name (@ident Bar))))))"
            )
        end)

        test.it("parses regular implementations", fn() throws:
            assert(
                module("""
                    extern:
                        impl Foo:
                            fn bar()
                        end
                    end
                    """) 
                == 
                "(@mod (@extern (@externimpl (@fqn (@name (@ident Foo))) " +
                "(@fndecl (@ident bar) (@type (@unit))))))"
            )
        end)

    end)

    test.group("struct instantiation", fn():
        test.it("passes the happy path", fn() throws:
            assert(
                expr("Foo{a: 42, b: \"foo\"}") 
                == 
                "(@structinst (@fqn (@name (@ident Foo))) " +
                "(@field (@ident a) (@int 42)) " +
                "(@field (@ident b) (@str foo)))"
            )
        end)

        test.it("parses fqn struct names", fn() throws:
            assert(
                expr("my::package::Bar{a: 42}") 
                == 
                "(@structinst (@fqn (@name (@ident my)) (@name (@ident package)) (@name (@ident Bar))) " +
                "(@field (@ident a) (@int 42)))"
            )
        end)

        test.it("parses empty struct instantiations", fn() throws:
            assert(expr("Foo{}") == "(@structinst (@fqn (@name (@ident Foo))))")
        end)

        test.it("supports field capture", fn() throws:
            assert(
                expr("Foo{a, b: c}") 
                == 
                "(@structinst (@fqn (@name (@ident Foo))) " +
                "(@field (@ident a) (@ident a)) " +
                "(@field (@ident b) (@ident c)))"
            )
        end)

        test.it("parses generics", fn() throws:
            assert(
                expr("Foo<Int>{a: 42}") 
                == 
                "(@structinst (@fqn (@name (@ident Foo) (@genericarg (@type (@fqn (@name (@ident Int))))))) " +
                "(@field (@ident a) (@int 42)))"
            )
        end)
    end)

    test.group("return", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("return 42") == "(@return (@int 42))")
        end)

        test.it("requires an expression", fn() throws:
            assert(expr("return") == "(@error eof)")
        end)
    end)

    test.group("field access", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("a.b") == "(@fieldaccess (@ident a) (@name (@ident b)))")
        end)

        test.it("parses chained field accesses", fn() throws:
            assert(
                expr("a.b.c") 
                == 
                "(@fieldaccess (@fieldaccess (@ident a) (@name (@ident b))) (@name (@ident c)))"
            )
        end)

        test.it("works with calls", fn() throws:
            assert(
                expr("a.b().c") 
                == 
                "(@fieldaccess (@call (@fieldaccess (@ident a) (@name (@ident b)))) (@name (@ident c)))"
            )
            assert(
                expr(
                    """
                    a()
                    .b().
                    c
                    """
                )
                ==
                "(@fieldaccess (@call (@fieldaccess (@call (@ident a)) (@name (@ident b)))) (@name (@ident c)))"
            )
        end)

        test.it("parses generic args", fn() throws:
            assert(
                expr("a.b<Int>") 
                == 
                "(@fieldaccess (@ident a) (@name (@ident b) (@genericarg (@type (@fqn (@name (@ident Int)))))))"
            )
        end)
    end)

    test.it("parses tuple access", fn() throws:
        assert(expr("a.0") == "(@tupleaccess (@ident a) 0)")
    end)

    test.group("index access", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("a[42]") == "(@indexaccess (@ident a) (@int 42))")
        end)

        test.it("parses chained index accesses", fn() throws:
            assert(
                expr("a[42][43]") 
                == 
                "(@indexaccess (@indexaccess (@ident a) (@int 42)) (@int 43))"
            )
        end)

        test.it("takes any expression as index", fn() throws:
            assert(
                expr("a[42 + 43]") 
                == 
                "(@indexaccess (@ident a) (@binexpr + (@int 42) (@int 43)))"
            )
        end)

        test.it("works with calls", fn() throws:
            assert(
                expr("a()[42][43]") 
                == 
                "(@indexaccess (@indexaccess (@call (@ident a)) (@int 42)) (@int 43))"
            )
            assert(
                expr(
                    """
                    a()
                    [42]
                    [43]
                    """
                )
                ==
                "(@indexaccess (@indexaccess (@call (@ident a)) (@int 42)) (@int 43))"
            )
        end)
    end)

    test.group("use statement", fn():
        test.it("passes the happy path", fn() throws:
            assert(
                module("use foo::bar") 
                == 
                "(@mod (@use (@ident foo) (@ident bar)))"
            )
        end)

        test.it("parses `*`", fn() throws:
            assert(
                module("use foo::bar::*") 
                == 
                "(@mod (@use wildcard (@ident foo) (@ident bar)))"
            )
        end)

        test.it("parses relative paths", fn() throws:
            assert(
                module("use .here::foo::bar") 
                == 
                "(@mod (@use relative (@ident here) (@ident foo) (@ident bar)))"
            )
        end)

        test.it("it cannot be used inside blocks", fn() throws:
            assert(
                module("""
                    fn test():
                        use foo::bar
                    end
                    """) 
                == 
                "(@error expr expected at test.kl:3:25-27)"
            )
        end)
    end)

    test.group("terminator expression", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("a;") == "(@terminatorexpr (@ident a))")
        end)

        test.it("has the highest precedence", fn() throws:
            assert(expr("a + b;") == "(@terminatorexpr (@binexpr + (@ident a) (@ident b)))")
        end)
    end)

    test.group("match", fn():
        test.it("passes the happy path", fn() throws:
            assert(
                expr("""
                    match a:
                        42 => 1
                    end
                    """)
                == 
                "(@match (@ident a) " +
                "(@matcharm (@pattern (@literal (@int 42))) (@block (@int 1))))"
            )
        end)

        test.it("parses multiple arms", fn() throws:
            assert(
                expr("""
                    match a:
                        42 => 1
                        43 => 2
                    end
                    """)
                == 
                "(@match (@ident a) " +
                "(@matcharm (@pattern (@literal (@int 42))) (@block (@int 1))) " +
                "(@matcharm (@pattern (@literal (@int 43))) (@block (@int 2))))"
            )
        end)

        test.group("pattern", fn():
            test.it("parses int literal patterns", fn() throws:
                assert(
                    expr("""
                        match a:
                            42 => 1
                        end
                        """)
                    == 
                    "(@match (@ident a) " +
                    "(@matcharm (@pattern (@literal (@int 42))) (@block (@int 1))))"
                )
            end)

            test.it("parses bool literal patterns", fn() throws:
                assert(
                    expr("""
                        match a:
                            true => 1
                        end
                        """)
                    == 
                    "(@match (@ident a) " +
                    "(@matcharm (@pattern (@literal (@bool true))) (@block (@int 1))))"
                )
            end)

            test.it("parses string literal patterns", fn() throws:
                assert(
                    expr("""
                        match a:
                            "foo" => 1
                        end
                        """)
                    == 
                    "(@match (@ident a) " +
                    "(@matcharm (@pattern (@literal (@str foo))) (@block (@int 1))))"
                )
            end)

            test.it("parses ident patterns", fn() throws:
                assert(
                    expr("""
                        match a:
                            b => 1
                        end
                        """)
                    == 
                    "(@match (@ident a) " +
                    "(@matcharm (@pattern (@ident b)) (@block (@int 1))))"
                )
            end)

            test.it("parses fqn patterns", fn() throws:
                assert(
                    expr("""
                        match a:
                            Option::None => 1
                        end
                        """)
                    == 
                    "(@match (@ident a) " +
                    "(@matcharm (@pattern (@fqn (@name (@ident Option)) (@name (@ident None)))) " +
                    "(@block (@int 1))))"
                )
            end)

            test.it("parses wildcard patterns", fn() throws:
                assert(
                    expr("""
                        match a:
                            _ => 1
                        end
                        """)
                    == 
                    "(@match (@ident a) " +
                    "(@matcharm (@pattern (@wildcard)) (@block (@int 1))))"
                )
            end)

            test.it("parses int range patterns", fn() throws:
                assert(
                    expr("""
                        match a:
                            1..3 => 1
                            1..<3 => 2
                        end
                        """)
                    == 
                    "(@match (@ident a) " +
                    "(@matcharm (@pattern (@range (@int 1) .. (@int 3))) (@block (@int 1))) " +
                    "(@matcharm (@pattern (@range (@int 1) ..< (@int 3))) (@block (@int 2))))"
                )
            end)

            test.it("parses char range patterns", fn() throws:
                assert(
                    expr("""
                        match a:
                            'a'..'z' => 1
                            'a'..< 'z' => 2
                        end
                        """)
                    == 
                    "(@match (@ident a) " +
                    "(@matcharm (@pattern (@range (@char a) .. (@char z))) (@block (@int 1))) " +
                    "(@matcharm (@pattern (@range (@char a) ..< (@char z))) (@block (@int 2))))"
                )
            end)

            test.it("parses tuple patterns", fn() throws:
                assert(
                    expr("""
                        match a:
                            (1, a) => 1
                        end
                        """)
                    == 
                    "(@match (@ident a) " +
                    "(@matcharm (@pattern (@tuple (@pattern (@literal (@int 1))) " +
                    "(@pattern (@ident a)))) (@block (@int 1))))"
                )
            end)

            test.it("parses enum variant with fields patterns", fn() throws:
                assert(
                    expr("""
                        match a:
                            Foo::Bar(1, a) => 1
                            Bar(_) => 2
                        end
                        """)
                    == 
                    "(@match (@ident a) " +
                    "(@matcharm (@pattern (@enumvariant (@fqn (@name (@ident Foo)) (@name (@ident Bar))) " +
                    "(@pattern (@literal (@int 1))) (@pattern (@ident a)))) (@block (@int 1))) " +
                    "(@matcharm (@pattern (@enumvariant (@fqn (@name (@ident Bar))) (@pattern (@wildcard)))) " +
                    "(@block (@int 2))))"
                )
            end)

            test.it("parses struct patterns", fn() throws:
                assert(
                    expr("""
                        match a:
                            Foo{a: 1, b, c: _} => 1
                        end
                        """)
                    == 
                    "(@match (@ident a) " +
                    "(@matcharm (@pattern (@struct (@fqn (@name (@ident Foo))) " +
                    "(@field (@ident a) (@pattern (@literal (@int 1)))) " +
                    "(@field (@ident b) (@pattern (@ident b))) " +
                    "(@field (@ident c) (@pattern (@wildcard))))) " +
                    "(@block (@int 1))))"
                )
            end)

            test.it("parses or patterns", fn() throws:
                assert(
                    expr("""
                        match a:
                            1 | b | 't' => 1
                        end
                        """)
                    == 
                    "(@match (@ident a) " +
                    "(@matcharm (@pattern (@or (@pattern (@literal (@int 1))) " +
                    "(@pattern (@ident b)) (@pattern (@literal (@char t))))) " +
                    "(@block (@int 1))))"
                )
            end)

            test.it("parses or patterns in nested patterns", fn() throws:
                assert(
                    expr("""
                        match a:
                            Foo{a: 1 | 2, b: "foo" | "bar"} => 1
                        end
                        """)
                    == 
                    "(@match (@ident a) " +
                    "(@matcharm (@pattern (@struct (@fqn (@name (@ident Foo))) " +
                    "(@field (@ident a) (@pattern (@or (@pattern (@literal (@int 1))) " +
                    "(@pattern (@literal (@int 2)))))) (@field (@ident b) " +
                    "(@pattern (@or (@pattern (@literal (@str foo))) " +
                    "(@pattern (@literal (@str bar)))))))) " +
                    "(@block (@int 1))))"
                )
            end)
        end)
    end)

    enum ParseFn:
        Item
        Expr
        Block
        FnDecl
        Module
        Type
    end

    fn parse(src Str, parse_fn ParseFn) Str:
        test.log(f"testing: {src}")
        let tokens = Lexer::lex(src, "test.kl").collect()
        let parser = Parser::new(TokenIter::new(tokens))
        let res = match parse_fn:
            ParseFn::Item => parser.parse_item(parser.iter.force_next().unwrap())
            ParseFn::Expr => parser.parse_expr(parser.iter.force_next().unwrap())
            ParseFn::Module:
                let res = parser.parse_module()
                if res.is_error():
                    return res.unwrap_error().to_debug_str()
                end
                return res.unwrap().to_debug_str()
            end
            ParseFn::Type:
                let res = parser.parse_type(parser.iter.force_next().unwrap())
                if res.is_error():
                    return res.unwrap_error().to_debug_str()
                end
                return res.unwrap().to_debug_str()
            end
            ParseFn::FnDecl:
                let res = parser.parse_fn_decl(parser.iter.force_next().unwrap())
                if res.is_error():
                    return res.unwrap_error().to_debug_str()
                end
                return res.unwrap().to_debug_str()
            end
            ParseFn::Block: 
                let res = parser.parse_block()
                if res.is_error():
                    return res.unwrap_error().to_debug_str()
                end
                return res.unwrap().to_debug_str()
            end
        end
        if res.is_error():
            return res.unwrap_error().to_debug_str()
        end
        let opt = res.unwrap()
        if (opt.is_none()):
            return "no result"
        end
        opt.unwrap().to_debug_str()
    end

    fn expr(src Str) Str => parse(src, ParseFn::Expr)

    fn item(src Str) Str => parse(src, ParseFn::Item)

    fn block(src Str) Str => parse(src, ParseFn::Block)

    fn fndecl(src Str) Str => parse(src, ParseFn::FnDecl)

    fn module(src Str) Str => parse(src, ParseFn::Module)

    fn type(src Str) Str => parse(src, ParseFn::Type)

    test.run_and_exit()
end
