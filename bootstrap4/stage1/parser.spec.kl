use .lexer.Lexer
use .lexer.Token
use .parser.Parser
use .parser.TokenIter
use .parser.ParseItem
use .ast.ParseError
use .ast.ToDebugStr
use .ast.Expr
use .test.Test

fn main():
    mut test = Test.new_from_args("parser", env.args)

    test.it("ignores comments and whitespace", fn() throws:
        assert(expr("\n 42 -- comment") == "(@int 42)")
    end)

    test.it("parses identifiers", fn() throws:
        assert(expr("a") == "(@ident a)")
    end)

    test.group("blocks", fn():
        test.it("parses multi-line blocks", fn() throws:
            assert(block(": end") == "(@block)")
            assert(block(": 42 end") == "(@block (@int 42))")
            assert(block(": foo() 42 end") == "(@block (@call (@ident foo)) (@int 42))")
        end)

        test.it("parses items (like Fn) in multi-line blocks", fn() throws:
            assert(block(": fn main(): end end") == "(@block (@fn (@fndecl (@ident main) (@type (@unit))) (@block)))")
        end)

        test.it("parses single-line blocks", fn() throws:
            assert(block("=> 42") == "(@block (@int 42))")
            assert(block("=> foo() 42") == "(@block (@call (@ident foo)))")
        end)
    end)

    test.group("fndecl", fn():
        test.it("passes the happy path", fn() throws:
            assert(fndecl("fn main()") == "(@fndecl (@ident main) (@type (@unit)))")
        end)
    end)

    test.group("fn", fn():
        test.it("passes the happy path", fn() throws:
            assert(item("fn main(): end") == "(@fn (@fndecl (@ident main) (@type (@unit))) (@block))")
            assert(item("fn main(): 42 end") == "(@fn (@fndecl (@ident main) (@type (@unit))) (@block (@int 42)))")
        end)
    end)

    test.group("literals", fn():
        test.it("parses unit literals", fn() throws:
            assert(expr("()") == "(@unit)")
        end)

        test.it("parses unit literals only if `(` is immediately followed by `)`", fn() throws:
            -- It's not required for ambiguity reasons, but having whitespace in between
            -- obscures the intent of the code.
            assert(expr("()") == "(@unit)")
        end)

        test.it("parses boolean literals", fn() throws:
            assert(expr("true") == "(@bool true)")
            assert(expr("false") == "(@bool false)")
        end)

        test.it("parses string literals", fn() throws:
            assert(expr("\"\"") == "(@str)")
            assert(expr("\"\"\"foo\nbar\"\"\"") == "(@str foo\\nbar)")
        end)

        test.group("int", fn():
            test.it("passes the happy path", fn() throws:
                assert(expr("42") == "(@int 42)")
                assert(expr("-42") == "(@int -42)")
            end)

            test.it("detects integer overflow", fn() throws:
                -- todo: for now `Int` is defined as 32-but, but it should be 
                --       the platform's native int size (64-bit in most cases).
                assert(expr("2147483647") == "(@int 2147483647)")
                assert(expr("2147483648") == "(@error invalid int literal at test.kl:1:1)")
                assert(expr("-2147483648") == "(@int -2147483648)")
                assert(expr("-2147483649") == "(@error invalid int literal at test.kl:1:1)")
            end)
        end)
    end)

    test.group("f-string", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("f\"\"") == "(@fstr)")
            assert(expr("f\"foo\"") == "(@fstr (@str foo))")
            assert(expr("f\"foo {42}\"") == "(@fstr (@str foo ) (@int 42))")
        end)

        test.it("detects errors in f-string expressions", fn() throws:
            -- `for` is a keyword and not an expression.
            assert(expr("f\"{for}\"") == "(@error expr expected at test.kl:1:4-6)")
        end)
    end)

    test.group("calls", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("test()") == "(@call (@ident test))")
            assert(expr("test(42)") == "(@call (@ident test) (@int 42))")
            assert(expr("test(42, 43)") == "(@call (@ident test) (@int 42) (@int 43))")
        end)

        test.it("ignores trailing comma in argument list", fn() throws:
            assert(expr("test(42,)") == "(@call (@ident test) (@int 42))")
            assert(expr("test(42, 43,)") == "(@call (@ident test) (@int 42) (@int 43))")
        end)

        test.it("requires `(` to be an immediate token after the call target", fn() throws:
            -- This is to resolve ambiguity between calls, tuples, and the unit literal.
            assert(expr("test ()") == "(@ident test)")
            assert(expr("test--- comment ---()") == "(@ident test)")
        end)

        test.it("can chain calls", fn() throws:
            assert(expr("test()()") == "(@call (@call (@ident test)))")
        end)
    end)

    test.group("module", fn():
        test.it("passes the happy path", fn() throws:
            assert(
                module("""
                    fn main():
                    end
                    """) 
                == 
                "(@mod (@fn (@fndecl (@ident main) (@type (@unit))) (@block)))"
            )
        end)
    end)

    test.group("types", fn():
        test.it("parses literal type names", fn() throws:
            assert(type("Int") == "(@type (@name (@seg (@ident Int))))")
        end)
    end)

    test.group("variable declarations", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("let a Int = 42") == "(@let (@ident a) (@type (@name (@seg (@ident Int)))) (@int 42))")
        end)

        test.it("does not require a type annotation", fn() throws:
            assert(expr("let a = 42") == "(@let (@ident a) (@type (@infer)) (@int 42))")
        end)

        test.it("respects associativity", fn() throws:
            assert(expr("let a = b or c") == "(@let (@ident a) (@type (@infer)) (@binexpr or (@ident b) (@ident c)))")
        end)

        test.it("parses `mut`", fn() throws:
            assert(expr("mut a = 42") == "(@mut (@ident a) (@type (@infer)) (@int 42))")
        end)
    end)

    test.group("if", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("if true: end") == "(@if (@bool true) (@block))")
            assert(expr("if true: 42 end") == "(@if (@bool true) (@block (@int 42)))")
        end)

        test.it("parses if / else", fn() throws:
            assert(expr("if true: 42 else: 43 end") == "(@if (@bool true) (@block (@int 42)) (@block (@int 43)))")
            assert(expr("if true => 42 else => 43") == "(@if (@bool true) (@block (@int 42)) (@block (@int 43)))")
        end)
    end)

    test.group("binary expressions", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("1 + 2") == "(@binexpr + (@int 1) (@int 2))")
        end)

        test.it("respects operator precedence", fn() throws:
            assert(expr("1 + 2 * 3") == "(@binexpr + (@int 1) (@binexpr * (@int 2) (@int 3)))")
        end)

        test.it("respects operator associativity (left)", fn() throws:
            assert(expr("1 + 2 + 3") == "(@binexpr + (@binexpr + (@int 1) (@int 2)) (@int 3))")
        end)

        test.it("parses all binary operators", fn() throws:
            assert(expr("1 + 2") == "(@binexpr + (@int 1) (@int 2))")
            assert(expr("1 - 2") == "(@binexpr - (@int 1) (@int 2))")
            assert(expr("1 * 2") == "(@binexpr * (@int 1) (@int 2))")
            assert(expr("1 / 2") == "(@binexpr / (@int 1) (@int 2))")
            assert(expr("1 == 2") == "(@binexpr == (@int 1) (@int 2))")
            assert(expr("1 != 2") == "(@binexpr != (@int 1) (@int 2))")
            assert(expr("1 < 2") == "(@binexpr < (@int 1) (@int 2))")
            assert(expr("1 <= 2") == "(@binexpr <= (@int 1) (@int 2))")
            assert(expr("1 > 2") == "(@binexpr > (@int 1) (@int 2))")
            assert(expr("1 >= 2") == "(@binexpr >= (@int 1) (@int 2))")
            assert(expr("1 and 2") == "(@binexpr and (@int 1) (@int 2))")
            assert(expr("1 or 2") == "(@binexpr or (@int 1) (@int 2))")
        end)

        test.it("respects logical associativity", fn() throws:
            assert(
                expr("1 and 2 or 3 and 4") 
                == 
                "(@binexpr or (@binexpr and (@int 1) (@int 2)) (@binexpr and (@int 3) (@int 4)))"
            )
        end)

        test.it("respects parentheses", fn() throws:
            assert(expr("(1 + 2) * 3") == "(@binexpr * (@binexpr + (@int 1) (@int 2)) (@int 3))")
        end)
    end)

    test.group("unary expressions", fn():
        test.it("parses `not` expressions", fn() throws:
            assert(expr("not true") == "(@unexpr not (@bool true))")
        end)

        test.it("parses `-` (negation) expressions", fn() throws:
            assert(expr("- 42") == "(@unexpr - (@int 42))")
            -- Note: `-2147483648` is a valid int literal, but `- 2147483648` is not, because
            --       the lexer will tokenize it as `-` and `2147483648` (two tokens). So the
            --       parser will try to parse the integer literal, and fail because it's out
            --       of range.
            assert(expr("- 2147483648") == "(@error invalid int literal at test.kl:1:3)")
        end)

        test.it("respects precedence and associativity", fn() throws:
            assert(expr("not true or false") == "(@binexpr or (@unexpr not (@bool true)) (@bool false))")
            assert(expr("not a or not b") == "(@binexpr or (@unexpr not (@ident a)) (@unexpr not (@ident b)))")
            assert(expr("- 42 + 43") == "(@binexpr + (@unexpr - (@int 42)) (@int 43))")
        end)
    end)

    test.group("assignment", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("a = 42") == "(@assign (@ident a) (@int 42))")
        end)

        test.it("respects associativity", fn() throws:
            assert(expr("a = b or c") == "(@assign (@ident a) (@binexpr or (@ident b) (@ident c)))")
        end)
    end)

    test.group("loop", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("loop: end") == "(@loop (@block))")
            assert(expr("loop: 42 end") == "(@loop (@block (@int 42)))")
        end)

        test.it("parses `break`", fn() throws:
            assert(expr("loop: break end") == "(@loop (@block (@break)))")
        end)

        test.it("parses `continue`", fn() throws:
            assert(expr("loop: continue end") == "(@loop (@block (@continue)))")
        end)
    end)


    enum ParseFn:
        Item
        Expr
        Block
        FnDecl
        Module
        Type
    end

    fn parse(src Str, parse_fn ParseFn) Str:
        test.log(f"testing: {src}")
        let tokens = Lexer.lex(src, "test.kl").collect()
        let parser = Parser.new(TokenIter.new(tokens))
        let res = match parse_fn:
            ParseFn.Item => parser.parse_item(parser.iter.force_next().unwrap())
            ParseFn.Expr => parser.parse_expr(parser.iter.force_next().unwrap())
            ParseFn.Module:
                let res = parser.parse_module()
                if res.is_error():
                    return res.unwrap_error().to_debug_str()
                end
                return res.unwrap().to_debug_str()
            end
            ParseFn.Type:
                let res = parser.parse_type(parser.iter.force_next().unwrap())
                if res.is_error():
                    return res.unwrap_error().to_debug_str()
                end
                return res.unwrap().to_debug_str()
            end
            ParseFn.FnDecl:
                let res = parser.parse_fn_decl(parser.iter.force_next().unwrap())
                if res.is_error():
                    return res.unwrap_error().to_debug_str()
                end
                return res.unwrap().to_debug_str()
            end
            ParseFn.Block: 
                let res = parser.parse_block()
                if res.is_error():
                    return res.unwrap_error().to_debug_str()
                end
                return res.unwrap().to_debug_str()
            end
        end
        if res.is_error():
            return res.unwrap_error().to_debug_str()
        end
        let opt = res.unwrap()
        if (opt.is_none()):
            return "no result"
        end
        opt.unwrap().to_debug_str()
    end

    fn expr(src Str) Str => parse(src, ParseFn.Expr)

    fn item(src Str) Str => parse(src, ParseFn.Item)

    fn block(src Str) Str => parse(src, ParseFn.Block)

    fn fndecl(src Str) Str => parse(src, ParseFn.FnDecl)

    fn module(src Str) Str => parse(src, ParseFn.Module)

    fn type(src Str) Str => parse(src, ParseFn.Type)

    test.run_and_exit()
end
