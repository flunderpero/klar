use .lexer.Lexer
use .lexer.Token
use .parser.Parser
use .parser.TokenIter
use .ast.ParseError
use .ast.ToDebugStr
use .ast.Item
use .ast.Expr
use .test.Test

fn main():
    mut test = Test.new_from_args("parser", env.args)

    test.it("ignores comments and whitespace", fn() throws:
        assert(expr("\n 42 // comment") == "(@int 42)")
    end)

    test.it("parses identifiers", fn() throws:
        assert(expr("a") == "(@ident a)")
    end)

    test.it("parses multi-line blocks", fn() throws:
        assert(block(": end") == "(@block)")
        assert(block(": 42 end") == "(@block (@int 42))")
    end)

    test.it("parses fn definitions", fn() throws:
        assert(item("fn main(): end") == "(@fndef (@fndecl main) (@block))")
        assert(item("fn main(): 42 end") == "(@fndef (@fndecl main) (@block (@int 42)))")
    end)

    test.group("literals", fn():
        test.it("parses unit", fn() throws:
            assert(expr("()") == "(@unit)")
        end)

        test.it("parses unit only if `)` immediately follows `(`", fn() throws:
            assert(expr("()") == "(@unit)")
        end)

        test.group("int", fn():
            test.it("passes the happy path", fn() throws:
                assert(expr("42") == "(@int 42)")
                assert(expr("-42") == "(@int -42)")
            end)

            test.it("detects integer overflow", fn() throws:
                assert(expr("2147483647") == "(@int 2147483647)")
                assert(expr("2147483648") == "(@error invalid int literal)")
                assert(expr("-2147483648") == "(@int -2147483648)")
                assert(expr("-2147483649") == "(@error invalid int literal)")
            end)
        end)
    end)

    test.group("calls", fn():
        test.it("passes the happy path", fn() throws:
            assert(expr("main()") == "(@call (@ident main))")
            assert(expr("main(42)") == "(@call (@ident main) (@int 42))")
            assert(expr("main(42, 43)") == "(@call (@ident main) (@int 42) (@int 43))")
        end)

        test.it("ignores trailing comma in argument list", fn() throws:
            assert(expr("main(42,)") == "(@call (@ident main) (@int 42))")
            assert(expr("main(42, 43,)") == "(@call (@ident main) (@int 42) (@int 43))")
        end)

        test.it("requires `(` to be an immediate token after the call target", fn() throws:
            assert(expr("main ()") == "(@ident main)")
            assert(expr("main--- comment ---()") == "(@ident main)")
        end)

        test.it("can chain calls", fn() throws:
            assert(expr("main()()") == "(@call (@call (@ident main)))")
        end)
    end)

    enum ParseFn:
        ParseItem
        ParseExpr
        ParseBlock
    end

    fn parse(src str, parse_fn ParseFn) str:
        test.log(f"testing: {src}")
        let tokens = Lexer.lex(src, "test.kl").collect()
        let parser = Parser.new(TokenIter.new(tokens))
        let res = match parse_fn:
            ParseItem => parser.parse_item(parser.iter.force_next().unwrap())
            ParseExpr => parser.parse_expr(parser.iter.force_next().unwrap())
            ParseBlock: 
                let res = parser.parse_block()
                if res.is_error():
                    return res.unwrap_error().to_debug_str()
                end
                return res.unwrap().to_debug_str()
            end
        end
        if res.is_error():
            return res.unwrap_error().to_debug_str()
        end
        let opt = res.unwrap()
        if (opt.is_none()):
            return "no result"
        end
        return opt.unwrap().to_debug_str()
    end

    fn expr(src str) str => parse(src, ParseFn.ParseExpr)

    fn item(src str) str => parse(src, ParseFn.ParseItem)

    fn block(src str) str => parse(src, ParseFn.ParseBlock)

    test.run_and_exit()
end
