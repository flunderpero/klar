--- A little test "framework".
---

struct Test:
    verbose Bool
    root_group TestGroup
    collect_group TestGroup
    logger TestLogger
end

struct TestCase:
    name Str
    f (fn() throws)
end

struct TestGroup:
    name Str
    tests Vector<TestCase>
    groups Vector<TestGroup>
end

struct TestRunConfig:
    logger TestLogger
    verbose Bool
end

struct TestRunResult:
    passed Int
    failed Int
end

impl TestRunResult:
    fn new() TestRunResult:
        TestRunResult{passed: 0, failed: 0}
    end

    fn update(mut self, other TestRunResult):
        self.passed = self.passed + other.passed
        self.failed = self.failed + other.failed
    end

    fn inc_passed(mut self) => self.passed = self.passed + 1

    fn inc_failed(mut self) => self.failed = self.failed + 1

    fn total(self) Int => self.passed + self.failed
end

struct TestLogger:
    indent_ Int
end

impl TestLogger:
    fn new() TestLogger:
        TestLogger{indent_: 0}
    end

    fn log(self, msg Str):
        let indent = " ".repeat(self.indent_ * 2)
        let indented_msg = msg.replace("\n", f"\n{indent}")
        print(f"{indent}{indented_msg}")
    end

    fn indent(mut self) => self.indent_ = self.indent_ + 1

    fn dedent(mut self) => self.indent_ = self.indent_ - 1
end

impl Test:
    fn new(name Str, verbose Bool) Test:
        let root_group = TestGroup::new(name)
        Test{verbose, root_group, collect_group: root_group, logger: TestLogger::new()}
    end

    fn new_from_args(name Str, args Vector<Str>) Test:
        --- Create a new test from command line arguments.

            Command line arguments:
              * `--verbose`: print test logs to stdout.
        ---
        let verbose = args.iter().any(fn(arg Str) => arg == "--verbose") 
        Test::new(name, verbose)
    end

    fn it(self, name Str, f (fn() throws)):
        --- Add a test to the current group.
        ---
        self.collect_group.tests.push(TestCase{name, f})
    end

    fn skip_it(self, name Str, f (fn() throws)):
        --- Ignore a test.
        ---
    end

    fn group(mut self, name Str, collect (fn())):
        --- Create a new group of tests. All tests and groups added within the 
            `collect` function will be added to the new group. 
        ---
        let collect_group = self.collect_group
        mut group = TestGroup::new(name)
        self.collect_group = group
        collect()
        self.collect_group = collect_group
        collect_group.groups.push(group)
    end

    fn log(self, msg Str):
        --- Log a message to the currently tested group's logger so that it will be
            indented properly.
        ---
        if self.verbose => self.logger.log(msg)
    end

    fn run(self) TestRunResult:
        --- Run all collected tests.
        ---
        let config = TestRunConfig{logger: self.logger, verbose: self.verbose}
        self.root_group.run(config)
    end

    fn run_and_exit(self):
        --- Run all collected tests and exit the program with the appropriate exit
            code.
        ---
        let result = self.run()
        if result.failed > 0 => exit(1)
        exit(0)
    end
end

impl TestGroup:
    fn new(name Str) TestGroup:
        TestGroup{ name, tests: Vector<TestCase>::new(), groups: Vector<TestGroup>::new() }
    end

    fn run(self, mut config TestRunConfig) TestRunResult:
        fn color(s Str, color Str) Str => f"\x1b[{color}m{s}\x1b[0m"
        mut result = TestRunResult::new()
        mut logger = config.logger
        let group_name = color(f"[{self.name}]", "90")
        self.tests.iter().for_each(fn(test TestCase):
            let name = f"it {test.name}"
            if config.verbose:
                logger.log(f"{group_name} {color("RUN", "33")}  {name}")
            end
            logger.indent()
            let old_panic_handler = register_panic_handler(fn(message, location, src):
                result.inc_failed()
                logger.log(f"{group_name} {color("FAIL", "31")} {name}: panicked with")
                logger.indent()
                logger.log(f"{message}\nat {location}")
                logger.dedent()
                exit(1)
            end)
            let res = test.f()
            logger.dedent()
            match res:
                Ok(_):
                    result.inc_passed()
                    logger.log(f"{group_name} {color("PASS", "32")} {name}")
                end
                Error(error):
                    result.inc_failed()
                    logger.log(f"{group_name} {color("FAIL", "31")} {name}")
                    logger.indent()
                    logger.log(f"{error}")
                    logger.dedent()
                end
            end
            register_panic_handler(old_panic_handler);
        end)
        self.groups.iter().for_each(fn(group TestGroup):
            logger.indent()
            let group_result = group.run(config)
            result.update(group_result)
            logger.dedent()
        end)
        if result.failed > 0:
            let s = color(f"{result.failed} / {result.total()} tests failed", "31")
            logger.log(f"{group_name} {s}")
        else:
            let s = color(f"{result.total()} tests passed", "32")
            logger.log(f"{group_name} {s}")
        end
        result
    end
end
